<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Horse Racing (Sprite Sheet)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:linear-gradient(#87CEEB,#98D98E);overflow:hidden}
    #gameCanvas{display:block;margin:20px auto;background:linear-gradient(#7CB342,#558B2F);border:5px solid #8B4513;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #ui{
      position:absolute;top:20px;left:20px;background:rgba(139,69,19,.92);
      color:#fff;padding:14px;border-radius:10px;min-width:320px;max-width:380px;
      max-height:80vh;overflow-y:auto;z-index:100
    }
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{min-width:64px;font-size:13px}
    .row input[type="text"], .row input[type="number"]{
      flex:1;border:none;border-radius:6px;padding:6px 8px;outline:none;font-size:13px
    }
    .row input[type="file"]{flex:1}
    .tiny{font-size:12px;opacity:.9}
    .horse-info{background:rgba(0,0,0,.25);padding:6px 8px;border-radius:6px;margin:8px 0}
    #controls{
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      background:rgba(139,69,19,.92);color:#fff;border-radius:10px;padding:14px 16px;
      display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center
    }
    button{
      background:#4CAF50;color:#fff;border:none;border-radius:6px;padding:10px 18px;
      cursor:pointer;transition:.2s;font-size:15px
    }
    button:hover{background:#45a049;transform:scale(1.05)}
    button:disabled{background:#666;transform:none;cursor:not-allowed}
    #winner{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(255,215,0,.96);padding:28px;border-radius:14px;font-weight:700;
      color:#8B4513;display:none;text-align:center;font-size:22px;box-shadow:0 0 40px rgba(255,215,0,.8);
      max-height:70vh;overflow-y:auto;max-width:500px
    }
    #raceResults{
      position:absolute;top:100px;right:20px;background:rgba(139,69,19,.95);
      color:#fff;padding:16px;border-radius:10px;min-width:280px;
      display:none;z-index:100;box-shadow:0 5px 20px rgba(0,0,0,.4)
    }
    .result-item{
      padding:8px;margin:6px 0;background:rgba(0,0,0,.3);border-radius:6px;
      display:flex;align-items:center;gap:10px;font-size:15px
    }
    .result-position{font-weight:bold;font-size:20px;min-width:35px;text-align:center}
    .result-medal{font-size:24px}
    #loadStatus{margin-left:10px;font-size:13px}
    #toggleUI{
      position:absolute;top:20px;right:20px;background:#4CAF50;color:#fff;
      border:none;border-radius:6px;padding:10px 18px;cursor:pointer;
      transition:.2s;font-size:15px;z-index:101
    }
    #toggleUI:hover{background:#45a049}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <button id="toggleUI">Hide Settings ‚öôÔ∏è</button>

  <div id="ui">
    <h3>üèá Sprite Horse Racing</h3>

    <div class="tiny" style="margin-bottom:8px">
      This page auto-loads <b>default.jpg</b> (6 frames, one row). You can override any horse with your own PNG/JPG.
    </div>

    <div class="row">
      <label>Frames</label>
      <input id="framesInput" type="number" min="2" max="32" />
    </div>
    <div class="row">
      <label>Scale</label>
      <input id="scaleInput" type="number" min="0.2" max="4" step="0.1" />
    </div>
    <div class="tiny">Tip: If the horse looks too small/large, change <b>Scale</b>.</div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">

    <div id="horseConfig"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <div id="leaderboard"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üìú Race History</h4>
    <div id="raceHistory" style="max-height:200px;overflow-y:auto"></div>
    <button id="clearHistoryBtn" style="margin-top:8px;font-size:12px;padding:6px 12px">Clear History</button>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üèÜ All Horses Complete Stats</h4>
    <div id="completeStats" style="max-height:250px;overflow-y:auto;font-size:12px"></div>
    
    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üíæ Export Settings</h4>
    <button id="downloadHorsesBtn" style="font-size:12px;padding:6px 12px;width:100%;margin-bottom:6px">Download horses.js</button>
    <button id="copyHorsesBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#2196F3;margin-bottom:6px">Copy horses.js Code</button>
    <button id="downloadRaceHistoryBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#FF9800;margin-bottom:6px">Download racehistory.js</button>
    <button id="copyRaceHistoryBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#FF5722">Copy racehistory.js Code</button>
    <div class="tiny" style="margin-top:6px;opacity:0.7">Download or copy current horse stats and race history. Save as .js files and link in HTML.</div>
  </div>

  <div id="controls">
    <button id="startBtn" disabled>Start Race</button>
    <button id="resetBtn" disabled>Reset Race</button>
    <button id="shuffleBtn" disabled>Shuffle Lanes</button>
    <span id="loadStatus" class="tiny">Loading sprites‚Ä¶</span>
  </div>

  <div id="winner"></div>
  <div id="raceResults"></div>

  <!-- Your horse stats -->
  <script src="horses.js"></script>
	
  <script src="race_params.js"></script>


  <script>
    /* ---------- SPRITE SETTINGS ---------- */
    const SPRITE_SRC_DEFAULT = "default.jpg";
    const SPRITE_FRAMES_DEFAULT = 6;
    const SPRITE_SCALE_DEFAULT  = 1.0;
    /* ------------------------------------ */

// Canvas & world
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Use params from race_params.js if available, otherwise defaults
const PARAMS = window.RACE_PARAMS || {cw:1200, ch:600, ww:5000, lg:10, lo:100, fl:4500};

canvas.width = PARAMS.cw;
canvas.height = PARAMS.ch;
const worldWidth = PARAMS.ww;
const laneGap = PARAMS.lg;
const laneOffset = PARAMS.lo;
const finishLine = PARAMS.fl;

console.log("üèá Using parameters:", PARAMS);

// Display parameters on screen
const paramInfo = document.createElement('div');
paramInfo.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:lime;padding:10px;border-radius:8px;font-family:monospace;font-size:12px;z-index:9999';
paramInfo.innerHTML = `‚öôÔ∏è Race Parameters:<br>World: ${worldWidth}px | Finish: ${finishLine}px<br>Canvas: ${canvas.width}x${canvas.height} | Lane Gap: ${laneGap}`;
document.body.appendChild(paramInfo);
setTimeout(() => paramInfo.remove(), 5000);


    let raceActive = false;
    let raceFinished = false;
    let cameraX = 0;
    let finishOrder = [];
    let raceHistory = []; // Store all race results
    let raceNumber = 0;

    // Load race history from racehistory.js if available
    if (window.RACE_HISTORY_DATA) {
      raceHistory = window.RACE_HISTORY_DATA.races || [];
      raceNumber = window.RACE_HISTORY_DATA.raceNumber || 0;
      console.log('Loaded race history from racehistory.js:', raceHistory.length, 'races');
    }

    // Load race history from storage on startup
    async function loadRaceHistory() {
      // Skip loading from storage if racehistory.js was already loaded
      if (window.RACE_HISTORY_DATA) {
        updateRaceHistory();
        refreshLeaderboard();
        return;
      }
      
      try {
        // Try Claude.ai storage first
        if (window.storage) {
          const result = await window.storage.get('horse-race-history');
          if (result && result.value) {
            const data = JSON.parse(result.value);
            raceHistory = data.races || [];
            raceNumber = data.raceNumber || 0;
            console.log('Loaded race history from Claude storage:', raceHistory.length, 'races');
            updateRaceHistory();
            refreshLeaderboard();
            return;
          }
        }
      } catch (error) {
        console.log('Claude storage not available, trying localStorage');
      }
      
      // Fallback to localStorage
      try {
        const stored = localStorage.getItem('horse-race-history');
        if (stored) {
          const data = JSON.parse(stored);
          raceHistory = data.races || [];
          raceNumber = data.raceNumber || 0;
          console.log('Loaded race history from localStorage:', raceHistory.length, 'races');
          updateRaceHistory();
          refreshLeaderboard();
        }
      } catch (error) {
        console.log('No previous race history found');
      }
    }

    // Save race history to storage
    async function saveRaceHistory() {
      const data = JSON.stringify({
        races: raceHistory,
        raceNumber: raceNumber
      });
      
      // Try Claude.ai storage
      try {
        if (window.storage) {
          await window.storage.set('horse-race-history', data);
          console.log('Race history saved to Claude storage');
        }
      } catch (error) {
        console.log('Claude storage not available');
      }
      
      // Always save to localStorage as backup
      try {
        localStorage.setItem('horse-race-history', data);
        console.log('Race history saved to localStorage');
      } catch (error) {
        console.error('Failed to save race history:', error);
      }
    }

    // Shared sprite config
    const spriteConfig = {
      frames: SPRITE_FRAMES_DEFAULT,
      scale:  SPRITE_SCALE_DEFAULT,
      fps:    14
    };

    // Preload the default sprite
    const horseSprite = new Image();
    horseSprite.src = SPRITE_SRC_DEFAULT;

    // Fallback colors
    const palette = [
      "#8B0000","#FFD700","#4169E1","#FF4500","#2F4F4F","#32CD32","#9932CC","#FF69B4",
      "#00CED1","#D2691E","#E6E6FA","#DC143C","#708090","#FF6347","#9ACD32","#8A2BE2",
      "#00FA9A","#FFDAB9","#FF8C00","#1E90FF","#A0522D","#ADFF2F","#00BFFF","#20B2AA"
    ];

    if (!Array.isArray(window.HORSE_DATA) || HORSE_DATA.length === 0) {
      throw new Error("HORSE_DATA is missing or empty. Make sure horses.js is loaded before this script.");
    }

    const horses = HORSE_DATA.map((h, i) => ({
      name:  h.name,
      color: h.color || palette[i % palette.length],
      lane:  i + 1,
      x: 50,
      y: laneOffset + i * laneGap,
      speed: 0,
      step: 0,
      animTime: 0,
      sprite: null,
      finished: false,
      finishTime: null,
      stats: {
        baseSpeed:  Number(h.baseSpeed),
        stamina:    Number(h.stamina),
        sprint:     Number(h.sprint),
        variance:   Number(h.variance),
        fatigue:    Number(h.fatigue),
        kick:       Number(h.kick),
        finalBoost: Number(h.finalBoost)
      }
    }));

    // Build per-horse config panel
    const horseConfigEl = document.getElementById('horseConfig');
    function makeHorseRow(h) {
      const wrap = document.createElement('div');
      wrap.className = 'horse-info';

      wrap.innerHTML = `
        <div class="row">
          <label>Lane ${h.lane}</label>
          <input type="text" class="nm" value="${h.name}">
          <input type="text" class="hex" value="${h.color}" title="Color (badge)">
        </div>
        <div class="row">
          <label>Sprite</label>
          <input type="file" class="file" accept="image/png,image/webp,image/jpeg">
        </div>
      `;

      const statsHtml = document.createElement('div');
      statsHtml.innerHTML = `
        <div class="row"><label>Base</label>
          <input type="number" step="0.1" class="base" value="${h.stats.baseSpeed}">
          <label>Stam</label>
          <input type="number" step="0.05" class="stam" value="${h.stats.stamina}">
        </div>
        <div class="row"><label>Sprint</label>
          <input type="number" step="0.05" class="sprint" value="${h.stats.sprint}">
          <label>Var</label>
          <input type="number" step="0.05" class="var" value="${h.stats.variance}">
        </div>
        <div class="row"><label>Fatigue</label>
          <input type="number" step="0.05" class="fat" value="${h.stats.fatigue}">
        </div>
        <div class="row"><label>Kick</label>
          <input type="number" step="0.05" min="0" max="1" class="kick" value="${h.stats.kick}">
        </div>
        <div class="row"><label>Final</label>
          <input type="number" step="0.05" min="1" max="2" class="fboost" value="${h.stats.finalBoost}">
        </div>
      `;
      wrap.appendChild(statsHtml);

      wrap.querySelector('.nm').onchange = e => { h.name = e.target.value.trim() || h.name; refreshLeaderboard(); };
      wrap.querySelector('.hex').onchange = e => { h.color = e.target.value.trim() || h.color; refreshLeaderboard(); };

      statsHtml.querySelector('.base').oninput   = e => h.stats.baseSpeed = +e.target.value || h.stats.baseSpeed;
      statsHtml.querySelector('.stam').oninput   = e => h.stats.stamina   = +e.target.value || h.stats.stamina;
      statsHtml.querySelector('.sprint').oninput = e => h.stats.sprint    = +e.target.value || h.stats.sprint;
      statsHtml.querySelector('.var').oninput    = e => h.stats.variance  = +e.target.value || h.stats.variance;
      statsHtml.querySelector('.fat').oninput    = e => h.stats.fatigue   = +e.target.value || h.stats.fatigue;
      statsHtml.querySelector('.kick').oninput   = e => h.stats.kick      = +e.target.value || h.stats.kick;
      statsHtml.querySelector('.fboost').oninput = e => h.stats.finalBoost= +e.target.value || h.stats.finalBoost;

      wrap.querySelector('.file').onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { h.sprite = { img, url }; refreshButtonsIfLoaded(); };
        img.src = url;
      };

      return wrap;
    }
    horses.forEach(h => horseConfigEl.appendChild(makeHorseRow(h)));

    // Frames/Scale UI
    const framesInput = document.getElementById('framesInput');
    const scaleInput  = document.getElementById('scaleInput');
    framesInput.value = SPRITE_FRAMES_DEFAULT;
    scaleInput.value  = SPRITE_SCALE_DEFAULT;
    framesInput.oninput = () => { spriteConfig.frames = Math.max(2, Math.min(32, +framesInput.value||SPRITE_FRAMES_DEFAULT)); };
    scaleInput.oninput  = () => { spriteConfig.scale  = Math.max(0.2, Math.min(4, +scaleInput.value||SPRITE_SCALE_DEFAULT)); };

    // Track drawing
    function drawTrack() {
      ctx.fillStyle = '#558B2F';
      ctx.fillRect(0,0,worldWidth,canvas.height);

      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.setLineDash([10,5]);
      for (let i=0; i<=horses.length; i++) {
        ctx.beginPath();
        ctx.moveTo(0, laneOffset - laneGap/2 + i*laneGap);
        ctx.lineTo(worldWidth, laneOffset - laneGap/2 + i*laneGap);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Furlong markers
      const FURLONGS_TOTAL = 8;
      for (let f = 1; f <= FURLONGS_TOTAL; f++) {
        const x = 50 + (finishLine - 50) * (f / FURLONGS_TOTAL);
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 8]);
        ctx.beginPath();
        ctx.moveTo(x, laneOffset - laneGap / 2);
        ctx.lineTo(x, laneOffset - laneGap / 2 + horses.length * laneGap);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 2, laneOffset - laneGap / 2 - 14, 4, 10);
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'blue';
        ctx.fillText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
        ctx.restore();
      }

      // Finish line
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(finishLine, 0, 5, canvas.height);
      for (let i=0; i<canvas.height; i+=20) {
        ctx.fillStyle = (i/20)%2===0 ? 'white' : 'black';
        ctx.fillRect(finishLine+5, i, 15, 10);
        ctx.fillRect(finishLine+20, i+10, 15, 10);
      }
    }

  






// Sprite drawing with proper color tinting
function drawHorseSprite(horse, dt) {
  const { frames, scale, fps } = spriteConfig;
  const hasSprite = horse.sprite && horse.sprite.img && horse.sprite.img.complete;

  function drawName(yOffset){
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 4;
    ctx.strokeText(horse.name, 0, yOffset);
    ctx.fillStyle = '#fff';
    ctx.fillText(horse.name, 0, yOffset);
  }

  // Use default sprite if present
  if (!hasSprite && horseSprite.complete) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    const animFps = fps + horse.speed * 0.6;
    horse.animTime = (horse.animTime || 0) + animFps * dt;
    const frameWidth  = horseSprite.width / SPRITE_FRAMES_DEFAULT;
    const frameHeight = horseSprite.height;
    const frame       = Math.floor(horse.animTime) % SPRITE_FRAMES_DEFAULT;
    const drawWidth  = frameWidth  * SPRITE_SCALE_DEFAULT;
    const drawHeight = frameHeight * SPRITE_SCALE_DEFAULT;
    
    // Create temporary canvas for tinting
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = drawWidth;
    tempCanvas.height = drawHeight;
    
    // Draw horse to temp canvas
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    // Apply color tint using multiply blend
    tempCtx.globalCompositeOperation = 'multiply';
    tempCtx.fillStyle = horse.color;
    tempCtx.fillRect(0, 0, drawWidth, drawHeight);
    
    // Restore original alpha channel (removes background tinting)
    tempCtx.globalCompositeOperation = 'destination-in';
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    tempCtx.globalCompositeOperation = 'source-over';
    
    // Draw tinted horse
    ctx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2);
    
    drawName(-drawHeight * 0.6);
    ctx.restore();
    return;
  }

  // Fallback circle (already uses color)
  if (!hasSprite) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    ctx.fillStyle = horse.color;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(horse.lane, 0, 0);
    drawName(-30);
    ctx.restore();
    return;
  }

  // Custom sprite with color tint
  const img = horse.sprite.img;
  const frameW = Math.floor(img.width / frames);
  const frameH = img.height;
  const animFps = fps + horse.speed * 0.6;
  horse.animTime = (horse.animTime || 0) + animFps * dt;
  const frameIndex = Math.floor(horse.animTime) % frames;
  const drawW = frameW * scale;
  const drawH = frameH * scale;

  ctx.save();
  ctx.translate(horse.x, horse.y);
  
  // Create temporary canvas for tinting
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = drawW;
  tempCanvas.height = drawH;
  
  // Draw sprite frame
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  // Apply color tint
  tempCtx.globalCompositeOperation = 'multiply';
  tempCtx.fillStyle = horse.color;
  tempCtx.fillRect(0, 0, drawW, drawH);
  
  // Restore transparency
  tempCtx.globalCompositeOperation = 'destination-in';
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  tempCtx.globalCompositeOperation = 'source-over';
  
  // Draw tinted result
  ctx.drawImage(tempCanvas, -drawW*0.5, -drawH*0.5);

  drawName(-drawH * 0.6);
  ctx.restore();
}















    // Leaderboard & results
    const leaderboard = document.getElementById('leaderboard');
    const raceResults = document.getElementById('raceResults');
    const raceHistoryEl = document.getElementById('raceHistory');

  function refreshLeaderboard() {
  const sorted = [...horses].sort((a,b) => b.x - a.x);
  let html = '<h4 style="margin:8px 0">üèá Current Standings</h4>';
  sorted.forEach((h,i) => {
    const pct = Math.max(0, Math.round((h.x / finishLine) * 100));
    
    // Build race code
    let raceCode = '';
    raceHistory.forEach(race => {
      const result = race.results.find(r => r.name === h.name);
      if (result) {
        raceCode += result.position >= 10 ? '0' : result.position;
      }
    });
    const displayCode = raceCode || '----';
    
    // ADD STRATEGY BADGE
    const strategyBadge = h.strategy 
      ? `<span style="background:${getStrategyColor(h.strategy)};color:white;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px">${h.strategy}</span>`
      : '';
    
    // FIXED: Show everything in ONE div (not two!)
    html += `<div class="horse-info">
      ${i+1}. <b>${h.name}</b> ${strategyBadge} ‚Äî Lane ${h.lane} ‚Äî <span style="color:${h.color}">‚óè</span> ${pct}%
      <div class="tiny">Race history: ${displayCode}</div>
    </div>`;
  });
  leaderboard.innerHTML = html;
}

// ADD THIS HELPER FUNCTION
function getStrategyColor(strategy) {
  switch(strategy) {
    case 'FRONT_RUNNER': return '#ff4444';
    case 'PRESSER': return '#ff9800';
    case 'STALKER': return '#2196F3';
    case 'CLOSER': return '#9c27b0';
    default: return '#666';
  }
}




    function updateRaceHistory() {
      if (raceHistory.length === 0) {
        raceHistoryEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        updateCompleteStats();
        return;
      }
      
      let html = '';
      raceHistory.slice().reverse().forEach((race, idx) => {
        const actualRaceNum = raceHistory.length - idx;
        html += `<div style="background:rgba(0,0,0,0.2);padding:8px;margin:6px 0;border-radius:6px">
          <div style="font-weight:bold;margin-bottom:4px">Race #${actualRaceNum}</div>
          <div style="font-size:12px">`;
        
        race.results.forEach(r => {
          const medal = r.position === 1 ? 'ü•á' : r.position === 2 ? 'ü•à' : r.position === 3 ? 'ü•â' : '';
          html += `<div style="padding:2px 0">
            ${medal} ${r.position}. <span style="color:${r.color}">‚óè</span> ${r.name} (L${r.lane})
          </div>`;
        });
        
        html += `</div></div>`;
      });
      
      raceHistoryEl.innerHTML = html;
      updateCompleteStats();
    }

    function updateCompleteStats() {
      const completeStatsEl = document.getElementById('completeStats');
      
      if (raceHistory.length === 0) {
        completeStatsEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        return;
      }

      let html = '<div style="background:rgba(0,0,0,0.2);padding:8px;border-radius:6px">';
      
      horses.forEach(h => {
        // Build race code for this horse
        let raceCode = '';
        raceHistory.forEach(race => {
          const result = race.results.find(r => r.name === h.name);
          if (result) {
            raceCode += result.position >= 10 ? '0' : result.position;
          }
        });
        
        if (raceCode) {
          html += `<div style="padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1)">
            <span style="color:${h.color};font-size:16px">‚óè</span> 
            <b>${h.name}</b> - ${raceCode}
          </div>`;
        }
      });
      
      html += '</div>';
      completeStatsEl.innerHTML = html;
    }

    function updateRaceResults() {
      if (!raceActive && finishOrder.length === 0) {
        raceResults.style.display = 'none';
        return;
      }
      raceResults.style.display = 'block';
      let html = '<h3 style="margin:0 0 10px 0; font-size:18px;">üìä Race Results</h3>';

      if (finishOrder.length > 0) {
        finishOrder.forEach((h, i) => {
          const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
          html += `<div class="result-item">
            <span class="result-position">${i+1}${getOrdinalSuffix(i+1)}</span>
            ${medal ? `<span class="result-medal">${medal}</span>` : ''}
            <span style="color:${h.color};font-size:20px">‚óè</span>
            <span style="flex:1"><b>${h.name}</b><br/><small>Lane ${h.lane}</small></span>
          </div>`;
        });
      }

      const stillRacing = horses.filter(h => !h.finished);
      if (stillRacing.length > 0) {
        html += '<div style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.3)">';
        html += '<div style="font-size:13px;opacity:0.8;margin-bottom:6px">Still Racing:</div>';
        stillRacing.forEach(h => {
          const pct = Math.max(0, Math.min(100, Math.round((h.x / finishLine) * 100)));
          html += `<div style="padding:4px;margin:3px 0;font-size:13px">
            <span style="color:${h.color}">‚óè</span> ${h.name} - ${pct}%
          </div>`;
        });
        html += '</div>';
      }
      raceResults.innerHTML = html;
    }

    function getOrdinalSuffix(num) {
      const j = num % 10, k = num % 100;
      if (j === 1 && k !== 11) return 'st';
      if (j === 2 && k !== 12) return 'nd';
      if (j === 3 && k !== 13) return 'rd';
      return 'th';
    }

   
    // Race control
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const loadStatus = document.getElementById('loadStatus');

    function startRace() {
      if (raceActive) return;
      raceActive = true;
      raceFinished = false;
      finishOrder = [];
      horses.forEach(h => {
        h.finished = false;
        h.finishTime = null;
        h._lateKickUsed = false;
        h._finalBoostUsed = false;
        h._kickTimer = 0;
        h._kickCooldown = 0;
      });

      assignRacingStrategies(horses); // ‚≠ê ADD THIS LINE

      startBtn.disabled = true;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'block';
      lastTs = performance.now();
    }

    function resetRace() {
      raceActive = false;
      raceFinished = false;
      cameraX = 0;
      finishOrder = [];
      horses.forEach(h=>{
        h.x=50; h.speed=0; h.step=0; h.animTime=0;
        h.y = laneOffset + (h.lane-1)*laneGap;
        h._kickTimer = 0;
        h._kickCooldown = 0;
        h._finalBoostUsed = false;
        h._lateKickUsed = false;
        h.finished = false;
        h.finishTime = null;
      });
      startBtn.disabled = false;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'none';
      refreshLeaderboard();
    }



// ============================================
// UPDATE YOUR updateHorses() FUNCTION:
// Replace the physics calculation part with this
// ============================================

function updateHorses(dt) {
  if (!raceActive) return;

  // Precompute leader once per tick
  const leaderXGlobal = Math.max(...horses.map(hh => hh.x));

  horses.forEach(h => {
    const prog = Math.min(1, (h.x - 50) / (finishLine - 50)); // 0..1 race progress

    // --- Phase pacing (uses strategyParams + kickPhase) ---
    const sp = h.strategyParams || {};
    const earlyPace = sp.earlyPace ?? 0.9;
    const midPace   = sp.midPace   ?? 0.9;
    const latePace  = sp.latePace  ?? 0.95;
    const kickPhase = sp.kickPhase ?? 0.80;

    let paceTarget;
    if (prog < 0.33) {
      paceTarget = earlyPace;
    } else if (prog < Math.min(0.70, kickPhase)) {
      paceTarget = midPace;
    } else if (prog >= kickPhase) {
      paceTarget = latePace; // KICK phase
    } else {
      paceTarget = midPace;
    }

    // --- Base speed with strategy phase ---
    const baseSpeed = h.stats.baseSpeed * paceTarget;

    // --- Stamina effect (ramps up with distance) ---
    // Slightly gentler exponent for smoother degradation
    const staminaEffect = Math.pow(h.stats.stamina, 1.8 * prog);

    // --- Fatigue/pressure from leading (leader pays a tax) ---
    const isLeading = h.x >= leaderXGlobal - 5;
    const energyDrain = sp.energyDrain ?? 1.1;
    // Start applying leader pressure around halfway; scale with prog
    const tired = 1 - h.stats.fatigue * Math.max(0, prog - 0.5) * (isLeading ? energyDrain : 1.0);

    // --- Random variance (soft-capped to keep packs tight) ---
    const rawJitter = (Math.random() - 0.5) * (h.stats.variance ?? 0.1);
    const jitter = Math.max(-0.08, Math.min(0.08, rawJitter)); // clamp ¬±0.08

    // --- Initial speed before kick/surge logic ---
    let s = baseSpeed * staminaEffect * tired + jitter;

    // --- Kick bursts (your existing logic, kept) ---
    if (h._kickCooldown == null) h._kickCooldown = 0;
    if (h._kickTimer == null)    h._kickTimer    = 0;
    h._kickCooldown -= dt;
    h._kickTimer = Math.max(0, h._kickTimer - dt);

    if (h._kickCooldown <= 0 && Math.random() < 0.015 * h.stats.kick) {
      h._kickTimer = 0.6 + 0.8 * h.stats.kick;
      h._kickCooldown = 2.0 + Math.random() * 2.0;
    }

    if (prog > 0.82 && h._kickTimer === 0 && !h._lateKickUsed) {
      h._kickTimer = 0.7 + 0.9 * h.stats.kick;
      h._lateKickUsed = true;
    }

    const kickBoost = h._kickTimer > 0
      ? 1 + (0.20 + 0.80 * h.stats.kick) * (1 - prog * 0.3)
      : 1;
    s *= kickBoost;

    // --- STALKER mid/late awareness (catch-up + drafting + steady late) ---
    if (h.strategy === 'STALKER') {
      const behindPx = leaderXGlobal - h.x;

      // convert pixels to "lengths" (heuristic)
      const oneLengthPx = Math.max(1, (h.stats.baseSpeed || 1) * 12);
      const gapLengths = behindPx / oneLengthPx;

      // (A) Proportional mid-race catch-up (up to +8%)
      if (prog > 0.28 && prog < 0.74 && gapLengths > 0.8) {
        // base + scaled by how far back; capped
        const gain = Math.min(0.08, 0.02 + 0.03 * (gapLengths - 0.8));
        s *= (1 + gain);
      }

      // (B) Drafting bonus when within ~1‚Äì3 lengths of any horse ahead
      //     (helps them "stick" to the pack)
      const nearestAheadPx = horses.reduce((min, o) => {
        if (o === h || o.x <= h.x) return min;
        const d = o.x - h.x;
        return d < min ? d : min;
      }, Infinity);
      if (nearestAheadPx < 3 * oneLengthPx) {
        s *= 1.03; // small aero/pressure benefit
      }

      // (C) Reliable late steadiness
      if (prog > 0.80) {
        s *= 1.05;
      }

      // (D) Mid-late fatigue guard (keeps them from sagging too hard)
      if (prog > 0.55 && prog < 0.85) {
        s *= 1.02;
      }
    }



    // --- PRESSER late surge (gap-aware) ---
    if (h.strategy === 'PRESSER') {
      const surgeWindow  = sp.surgeWindow ?? 0.18; // last 18% of race
      const gapTrigger   = sp.gapTrigger  ?? 0.6;  // lengths behind before surge assist
      const kickMult     = sp.kickMult    ?? 1.12; // base kick multiplier for pressers

      // Start building earlier for pressers
      if (prog >= (sp.kickPhase ?? 0.70)) {
        s *= kickMult;

        // If still behind in final surge window, add capped catch-up
        if (prog >= (1 - surgeWindow)) {
          // convert px gap to "lengths"
          const gapPx = leaderXGlobal - h.x;
          const oneLengthPx = Math.max(1, (h.stats.baseSpeed || 1) * 12); // heuristic
          const gapLengths = gapPx / oneLengthPx;

          if (gapLengths > gapTrigger) {
            // smooth, bounded catch-up: stronger if farther back, capped
            const catchUp = Math.min(1.12, 1 + 0.06 * Math.tanh(gapLengths - gapTrigger));
            s *= catchUp;
          }
        }
      }
    }

    // --- Final boost for closers in last 10% (your logic, kept) ---
    if (!h._finalBoostUsed && prog > 0.9 && h.strategy === 'CLOSER') {
      s *= h.stats.finalBoost * 1.2;
      h._finalBoostUsed = true;
    }
    if (h._finalBoostUsed && prog > 0.9) {
      s *= 1.0 - (prog - 0.9) * 0.3; // taper off
    }

    // --- Safety floors & motion ---
    h.speed = Math.max(0.8, s);
    h.x += h.speed;
    h.step += h.speed * 0.08;

    // --- Finish detection (unchanged) ---
    if (h.x >= finishLine && !h.finished) {
      h.finished = true;
      h.finishTime = performance.now();
      finishOrder.push({
        name: h.name,
        lane: h.lane,
        color: h.color,
        position: finishOrder.length + 1,
        strategy: h.strategy
      });

      if (finishOrder.length === horses.length) {
        raceFinished = true;
        raceActive = false;
        showResults();
      }
    }

    if (h.finished && h.x > finishLine + 100) {
      h.speed *= 0.95;
    }
  });

  refreshLeaderboard();
  updateRaceResults();
}








    function shuffleLanes() {
      const ids = horses.map((_, i) => i + 1).sort(() => Math.random() - 0.5);
      horses.forEach((h,i) => {
        h.lane = ids[i];
        h.y = laneOffset + (h.lane-1)*laneGap;
      });
      refreshLeaderboard();
    }

    function showResults() {
      const el = document.getElementById('winner');
      let html = `<div style="font-size:28px; margin-bottom:16px;">üèÜ RACE COMPLETE üèÜ</div>`;
      html += '<div style="text-align:left;">';
      finishOrder.forEach((h, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
        html += `<div style="margin:10px 0; font-size:${22-i*1.5}px; padding:8px; background:rgba(139,69,19,0.3); border-radius:6px;">
          ${medal} <b>${i+1}${getOrdinalSuffix(i+1)}</b> - <span style="color:${h.color}">‚óè</span> ${h.name} <small style="opacity:0.8">(Lane ${h.lane})</small>
        </div>`;
      });
      html += '</div>';
      el.innerHTML = html;
      el.style.display = 'block';
      resetBtn.disabled = false;
      startBtn.disabled = true;
      
      // Save race to history
      raceNumber++;
      raceHistory.push({
        raceNum: raceNumber,
        results: finishOrder.map((h, i) => ({
          position: i + 1,
          name: h.name,
          lane: h.lane,
          color: h.color
        }))
      });
      updateRaceHistory();
      refreshLeaderboard(); // Update to show new "last race" positions
      saveRaceHistory(); // Save to storage
    }

    function refreshButtonsIfLoaded() {
      const allReady = horseSprite.complete || horses.some(h => h.sprite?.img?.complete);
      startBtn.disabled   = !allReady;
      resetBtn.disabled   = true;
      shuffleBtn.disabled = !allReady;
      loadStatus.textContent = allReady ? "Sprites loaded. Ready to race!" : "Loading sprites‚Ä¶";
    }
    horseSprite.onload = refreshButtonsIfLoaded;

    // Game loop with camera tracking
    let lastTs = performance.now();
    function loop(ts) {
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;

      if (raceActive || raceFinished) {
        const leader = Math.max(...horses.map(h => h.x));
        const targetCameraX = Math.max(0, Math.min(worldWidth - canvas.width, leader - canvas.width * 0.3));
        cameraX += (targetCameraX - cameraX) * 0.1;
      }

      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(-cameraX, 0);

      drawTrack();
      horses.slice().sort((a,b)=>a.y-b.y).forEach(h => drawHorseSprite(h, dt));

      ctx.restore();

      updateHorses(dt);
      requestAnimationFrame(loop);
    }

    // Buttons
    startBtn.onclick = startRace;
    resetBtn.onclick = resetRace;
    shuffleBtn.onclick = shuffleLanes;
    
    document.getElementById('clearHistoryBtn').onclick = () => {
      if (confirm('Clear all race history?')) {
        raceHistory = [];
        raceNumber = 0;
        updateRaceHistory();
        refreshLeaderboard();
        saveRaceHistory(); // Save cleared state
      }
    };

    // Download horses.js with current stats
    document.getElementById('downloadHorsesBtn').onclick = () => {
      const horseDataArray = horses.map(h => ({
        name: h.name,
        color: h.color,
        baseSpeed: h.stats.baseSpeed,
        stamina: h.stats.stamina,
        sprint: h.stats.sprint,
        variance: h.stats.variance,
        fatigue: h.stats.fatigue,
        kick: h.stats.kick,
        finalBoost: h.stats.finalBoost
      }));

      // Format as single lines
      const horseLines = horseDataArray.map(h => 
        `  { name: "${h.name}", color: "${h.color}", baseSpeed: ${h.baseSpeed}, stamina: ${h.stamina}, sprint: ${h.sprint}, variance: ${h.variance}, fatigue: ${h.fatigue}, kick: ${h.kick}, finalBoost: ${h.finalBoost} }`
      ).join(',\n');

      const jsContent = `// Horse Racing Data
// Edit these values to customize your horses

window.HORSE_DATA = [
${horseLines}
];
`;

      const blob = new Blob([jsContent], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'horses.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('horses.js downloaded! Replace your old horses.js file with this new one.');
    };

    // Copy horses.js to clipboard
    document.getElementById('copyHorsesBtn').onclick = () => {
      const horseDataArray = horses.map(h => ({
        name: h.name,
        color: h.color,
        baseSpeed: h.stats.baseSpeed,
        stamina: h.stats.stamina,
        sprint: h.stats.sprint,
        variance: h.stats.variance,
        fatigue: h.stats.fatigue,
        kick: h.stats.kick,
        finalBoost: h.stats.finalBoost
      }));

      // Format as single lines
      const horseLines = horseDataArray.map(h => 
        `  { name: "${h.name}", color: "${h.color}", baseSpeed: ${h.baseSpeed}, stamina: ${h.stamina}, sprint: ${h.sprint}, variance: ${h.variance}, fatigue: ${h.fatigue}, kick: ${h.kick}, finalBoost: ${h.finalBoost} }`
      ).join(',\n');

      const jsContent = `// Horse Racing Data
// Edit these values to customize your horses

window.HORSE_DATA = [
${horseLines}
];
`;

      navigator.clipboard.writeText(jsContent).then(() => {
        alert('‚úÖ horses.js code copied to clipboard!\n\n1. Open a text editor (Notepad, etc.)\n2. Paste (Ctrl+V)\n3. Save as "horses.js"\n4. Put it in the same folder as your HTML file');
      }).catch(err => {
        // Fallback: show in a text area for manual copy
        const textarea = document.createElement('textarea');
        textarea.value = jsContent;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '50%';
        textarea.style.transform = 'translate(-50%, -50%)';
        textarea.style.width = '80%';
        textarea.style.height = '80%';
        textarea.style.zIndex = '10000';
        textarea.style.background = 'white';
        textarea.style.color = 'black';
        textarea.style.padding = '20px';
        document.body.appendChild(textarea);
        textarea.select();
        alert('Copy this code manually (Ctrl+A then Ctrl+C), then close this box');
        setTimeout(() => document.body.removeChild(textarea), 30000);
      });
    };




// Dynamic Strategy Assignment System
// Assigns strategies based on how each horse compares to the AVERAGE of the race field

function assignRacingStrategies(horses) {
  // Calculate average stats for this race
  const avgBaseSpeed = horses.reduce((sum, h) => sum + h.stats.baseSpeed, 0) / horses.length;
  const avgStamina = horses.reduce((sum, h) => sum + h.stats.stamina, 0) / horses.length;
  const avgSprint = horses.reduce((sum, h) => sum + h.stats.sprint, 0) / horses.length;
  
    // ADD THIS: Adjust strategy based on race distance
  const raceLength = finishLine - 50; // Your race distance
  const isShortRace = raceLength < 3000;
  const isLongRace = raceLength > 6000;

  console.log('üèÅ Race Distance:', raceLength, isShortRace ? '(SHORT)' : isLongRace ? '(LONG)' : '(MEDIUM)');

  console.log('üèÅ Race Field Averages:', {
    baseSpeed: avgBaseSpeed.toFixed(2),
    stamina: avgStamina.toFixed(2),
    sprint: avgSprint.toFixed(2)
  });
  
  horses.forEach(horse => {
    // Compare this horse to the race average
    const speedRatio = horse.stats.baseSpeed / avgBaseSpeed;
    const staminaRatio = horse.stats.stamina / avgStamina;
    const sprintRatio = horse.stats.sprint / avgSprint;
    
    console.log(`\nüê¥ ${horse.name}:`, {
      speedRatio: speedRatio.toFixed(2),
      staminaRatio: staminaRatio.toFixed(2),
      sprintRatio: sprintRatio.toFixed(2)
    });
    
    // FRONT_RUNNER: Above average speed, decent stamina, below average sprint
    // These horses want to get out front early and try to hold on
    if (speedRatio > 1.05 && staminaRatio >= 0.95 && sprintRatio < 1.05) {
      horse.strategy = 'FRONT_RUNNER';
      horse.strategyParams = {
        earlyPace: isShortRace ? 1.0 : 0.95,    // Go ALL OUT in short races
        midPace: isLongRace ? 0.75 : 0.85,      // Save more in long races
        latePace: isLongRace ? 0.65 : 0.75,     // Fade harder in long races
        energyDrain: isLongRace ? 1.5 : 1.3,    // Drain faster in long races
        kickPhase: 0.95       // No real kick, just survival mode
      };
    }
    
    // PRESSER: High speed, high stamina, good sprint
    // Sit just behind leaders, strike when they tire
    else if (speedRatio > 1.02 && staminaRatio > 1.0 && sprintRatio > 1.0) {
      horse.strategy = 'PRESSER';
      // compute a tailored late burst from the horse's traits
      const lateBase   = 1.06;                                // base late pace
      const lateBoost  = Math.min(0.10, 0.06*(sprintRatio-1) + 0.04*(staminaRatio-1));
      const latePace   = lateBase + lateBoost;                // ~1.06‚Äì1.16
      // kick strength scales with sprint&stamina; cap to keep sane
      const kickMult   = Math.min(1.22, 1.10 + 0.10*(sprintRatio-1) + 0.06*(staminaRatio-1));

      horse.strategyParams = {
        earlyPace: 0.78,      // Sit close but not in lead
        midPace: 0.88,        // Move up gradually
        latePace: latePace,       // Accelerate when leaders fade
        energyDrain: 1.02,     // Moderate energy use
        kickPhase: 0.70,      // Strike at 70% of race
        kickMult:  kickMult,    // extra multiplier in the kick
        surgeWindow: 0.18,      // final 18% of race is surge zone
        gapTrigger: 0.6         // if >0.6 "lengths" behind, trigger catch-up

      };
    }
    
    // CLOSER: Below average early speed BUT high stamina + high sprint
    // Save energy, massive late kick
    else if (sprintRatio > 1.1 && staminaRatio > 1.05) {
      horse.strategy = 'CLOSER';
      horse.strategyParams = {
        earlyPace: isShortRace ? 0.75 : 0.65,   // Can't sit TOO far back in short races
        midPace: 0.70,        // Still waiting...
        latePace: isLongRace ? 1.35 : 1.25,     // BIGGER kick in long races!
        energyDrain: isLongRace ? 0.7 : 0.8,    // Save even more in long races
        kickPhase: isShortRace ? 0.70 : 0.80    // Start kick earlier in short races
      };
    }
    
    // STALKER: Balanced approach - most common strategy
    // Mid-pack, steady, reliable kick
    else {
      horse.strategy = 'STALKER';
      horse.strategyParams = {
        earlyPace: 0.75,      // Mid-pack
        midPace: 0.85,        // Gradually advance
        latePace: 1.05,       // Moderate late kick
        energyDrain: 1.0,     // Normal energy drain
        kickPhase: 0.70       // Begin move at 70%
      };
    }
    
    console.log(`   Strategy: ${horse.strategy}`);
  });
  
  // Log strategy distribution
  const stratCounts = {};
  horses.forEach(h => {
    stratCounts[h.strategy] = (stratCounts[h.strategy] || 0) + 1;
  });
  console.log('\nüìä Strategy Distribution:', stratCounts);
}









    // Download racehistory.js
    document.getElementById('downloadRaceHistoryBtn').onclick = () => {
      const jsContent = `// Race History Data
// This file stores all completed race results

window.RACE_HISTORY_DATA = {
  raceNumber: ${raceNumber},
  races: ${JSON.stringify(raceHistory, null, 2)}
};
`;

      const blob = new Blob([jsContent], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'racehistory.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('racehistory.js downloaded! Add this line to your HTML before the main script tag.');
    };

    // Copy racehistory.js to clipboard
    document.getElementById('copyRaceHistoryBtn').onclick = () => {
      const jsContent = `// Race History Data
// This file stores all completed race results

window.RACE_HISTORY_DATA = {
  raceNumber: ${raceNumber},
  races: ${JSON.stringify(raceHistory, null, 2)}
};
`;

      navigator.clipboard.writeText(jsContent).then(() => {
        alert('racehistory.js code copied to clipboard!');
      }).catch(err => {
        const textarea = document.createElement('textarea');
        textarea.value = jsContent;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '50%';
        textarea.style.transform = 'translate(-50%, -50%)';
        textarea.style.width = '80%';
        textarea.style.height = '80%';
        textarea.style.zIndex = '10000';
        textarea.style.background = 'white';
        textarea.style.color = 'black';
        textarea.style.padding = '20px';
        document.body.appendChild(textarea);
        textarea.select();
        alert('Copy this code manually then close this box');
        setTimeout(() => document.body.removeChild(textarea), 30000);
      });
    };

    // Toggle UI visibility
    const toggleUIBtn = document.getElementById('toggleUI');
    const uiPanel = document.getElementById('ui');
    toggleUIBtn.onclick = () => {
      uiPanel.classList.toggle('hidden');
      toggleUIBtn.textContent = uiPanel.classList.contains('hidden') ? 'Show Settings ‚öôÔ∏è' : 'Hide Settings ‚öôÔ∏è';
    };

    // Kick off
    loadRaceHistory(); // Load saved history
    refreshButtonsIfLoaded();
    refreshLeaderboard();
    updateRaceHistory();
    requestAnimationFrame(loop);
  </script>
</body>
</html>