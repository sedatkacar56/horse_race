<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Horse Racing (Sprite Sheet)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:linear-gradient(#87CEEB,#98D98E);overflow:hidden}
    #gameCanvas{display:block;margin:20px auto;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #ui{
      position:absolute;top:20px;left:20px;background:rgba(139,69,19,.92);
      color:#fff;padding:14px;border-radius:10px;min-width:320px;max-width:380px;
      max-height:80vh;overflow-y:auto;z-index:100
    }
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{min-width:64px;font-size:13px}
    .row input[type="text"], .row input[type="number"]{
      flex:1;border:none;border-radius:6px;padding:6px 8px;outline:none;font-size:13px
    }
    .row input[type="file"]{flex:1}
    .tiny{font-size:12px;opacity:.9}
    .horse-info{background:rgba(0,0,0,.25);padding:6px 8px;border-radius:6px;margin:8px 0}
    #controls{
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      background:rgba(139,69,19,.92);color:#fff;border-radius:10px;padding:14px 16px;
      display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center
    }
    button{
      background:#4CAF50;color:#fff;border:none;border-radius:6px;padding:10px 18px;
      cursor:pointer;transition:.2s;font-size:15px
    }
    button:hover{background:#45a049;transform:scale(1.05)}
    button:disabled{background:#666;transform:none;cursor:not-allowed}
    #winner{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(255,215,0,.96);padding:28px;border-radius:14px;font-weight:700;
      color:#8B4513;display:none;text-align:center;font-size:22px;box-shadow:0 0 40px rgba(255,215,0,.8);
      max-height:70vh;overflow-y:auto;max-width:500px
    }
    #raceResults{
      position:absolute;top:100px;right:20px;background:rgba(139,69,19,.95);
      color:#fff;padding:16px;border-radius:10px;min-width:280px;
      display:none;z-index:100;box-shadow:0 5px 20px rgba(0,0,0,.4)
    }
    .result-item{
      padding:8px;margin:6px 0;background:rgba(0,0,0,.3);border-radius:6px;
      display:flex;align-items:center;gap:10px;font-size:15px
    }
    .result-position{font-weight:bold;font-size:20px;min-width:35px;text-align:center}
    .result-medal{font-size:24px}
    #loadStatus{margin-left:10px;font-size:13px}
    #toggleUI{
      position:absolute;top:20px;right:20px;background:#4CAF50;color:#fff;
      border:none;border-radius:6px;padding:10px 18px;cursor:pointer;
      transition:.2s;font-size:15px;z-index:101
    }
    #toggleUI:hover{background:#45a049}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <button id="toggleUI">Hide Settings ‚öôÔ∏è</button>

  <div id="ui">
    <h3>üèá Sprite Horse Racing</h3>
  
    <div class="row">
      <label>Frames</label>
      <input id="framesInput" type="number" min="2" max="32" />
    </div>
    <div class="row">
      <label>Scale</label>
      <input id="scaleInput" type="number" min="0.2" max="4" step="0.1" />
    </div>
    <div class="tiny">Tip: If the horse looks too small/large, change <b>Scale</b>.</div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">

    <div id="leaderboard"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üìú Race History</h4>
    <div id="raceHistory" style="max-height:200px;overflow-y:auto"></div>
    <button id="clearHistoryBtn" style="margin-top:8px;font-size:12px;padding:6px 12px">Clear History</button>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üèÜ All Horses Complete Stats</h4>
    <div id="completeStats" style="max-height:250px;overflow-y:auto;font-size:12px"></div>
    
    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üíæ Export Settings</h4>
    <button id="downloadRaceHistoryBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#FF9800;margin-bottom:6px">Download racehistory.js</button>
  </div>

  <div id="controls">
    <button id="startBtn" disabled>Start Race</button>
    <button id="resetBtn" disabled>Reset Race</button>
    <span id="loadStatus" class="tiny">Loading sprites‚Ä¶</span>
  </div>

  <div id="winner"></div>
  <div id="raceResults"></div>

  <!-- Your horse stats -->
  <script src="horses.js"></script>
	
  <script src="race_params.js"></script>


  <script>
    /* ---------- SPRITE SETTINGS ---------- */
    const SPRITE_SRC_DEFAULT = "default.jpg";
    const SPRITE_FRAMES_DEFAULT = 6;
    const SPRITE_SCALE_DEFAULT  = 1.0;
    /* ------------------------------------ */

// Canvas & world
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Apply track colors from horses.js
if (window.TRACK_STYLE) {
  const top = window.TRACK_STYLE.backgroundTop || '#7CB342';
  const bottom = window.TRACK_STYLE.backgroundBottom || '#558B2F';
  const border = window.TRACK_STYLE.border || '#8B4513';
  canvas.style.background = `linear-gradient(${top}, ${bottom})`;
  canvas.style.border = `8px solid ${border}`;
}



// Use params from race_params.js if available, otherwise defaults
const PARAMS = window.RACE_PARAMS || {cw:1200, ch:600, ww:5000, lg:10, lo:100, fl:4500};

canvas.width = PARAMS.cw;
canvas.height = PARAMS.ch;
const worldWidth = PARAMS.ww;
const laneGap = PARAMS.lg;
const laneOffset = PARAMS.lo;
const finishLine = PARAMS.fl;

console.log("üèá Using parameters:", PARAMS);

// Display parameters on screen
const paramInfo = document.createElement('div');
paramInfo.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:lime;padding:10px;border-radius:8px;font-family:monospace;font-size:12px;z-index:9999';
paramInfo.innerHTML = `‚öôÔ∏è Race Parameters:<br>World: ${worldWidth}px | Finish: ${finishLine}px<br>Canvas: ${canvas.width}x${canvas.height} | Lane Gap: ${laneGap}`;
document.body.appendChild(paramInfo);
setTimeout(() => paramInfo.remove(), 5000);


    let raceActive = false;
    let raceFinished = false;
    let cameraX = 0;
    let finishOrder = [];
    let raceHistory = []; // Store all race results
    let raceNumber = 0;

    // Load race history from racehistory.js if available
    if (window.RACE_HISTORY_DATA) {
      raceHistory = window.RACE_HISTORY_DATA.races || [];
      raceNumber = window.RACE_HISTORY_DATA.raceNumber || 0;
      console.log('Loaded race history from racehistory.js:', raceHistory.length, 'races');
    }

    // Load race history from storage on startup
    async function loadRaceHistory() {
      // Skip loading from storage if racehistory.js was already loaded
      if (window.RACE_HISTORY_DATA) {
        updateRaceHistory();
        refreshLeaderboard();
        return;
      }
      
      try {
        // Try Claude.ai storage first
        if (window.storage) {
          const result = await window.storage.get('horse-race-history');
          if (result && result.value) {
            const data = JSON.parse(result.value);
            raceHistory = data.races || [];
            raceNumber = data.raceNumber || 0;
            console.log('Loaded race history from Claude storage:', raceHistory.length, 'races');
            updateRaceHistory();
            refreshLeaderboard();
            return;
          }
        }
      } catch (error) {
        console.log('Claude storage not available, trying localStorage');
      }
      
      // Fallback to localStorage
      try {
        const stored = localStorage.getItem('horse-race-history');
        if (stored) {
          const data = JSON.parse(stored);
          raceHistory = data.races || [];
          raceNumber = data.raceNumber || 0;
          console.log('Loaded race history from localStorage:', raceHistory.length, 'races');
          updateRaceHistory();
          refreshLeaderboard();
        }
      } catch (error) {
        console.log('No previous race history found');
      }
    }

    // Save race history to storage
    async function saveRaceHistory() {
      const data = JSON.stringify({
        races: raceHistory,
        raceNumber: raceNumber
      });
      
      // Try Claude.ai storage
      try {
        if (window.storage) {
          await window.storage.set('horse-race-history', data);
          console.log('Race history saved to Claude storage');
        }
      } catch (error) {
        console.log('Claude storage not available');
      }
      
      // Always save to localStorage as backup
      try {
        localStorage.setItem('horse-race-history', data);
        console.log('Race history saved to localStorage');
      } catch (error) {
        console.error('Failed to save race history:', error);
      }
    }

    // Shared sprite config
    const spriteConfig = {
      frames: SPRITE_FRAMES_DEFAULT,
      scale:  SPRITE_SCALE_DEFAULT,
      fps:    14
    };

    // Preload the default sprite
    const horseSprite = new Image();
    horseSprite.src = SPRITE_SRC_DEFAULT;

    // Fallback colors
    const palette = [
      "#8B0000","#FFD700","#4169E1","#FF4500","#2F4F4F","#32CD32","#9932CC","#FF69B4",
      "#00CED1","#D2691E","#E6E6FA","#DC143C","#708090","#FF6347","#9ACD32","#8A2BE2",
      "#00FA9A","#FFDAB9","#FF8C00","#1E90FF","#A0522D","#ADFF2F","#00BFFF","#20B2AA"
    ];

    if (!Array.isArray(window.HORSE_DATA) || HORSE_DATA.length === 0) {
      throw new Error("HORSE_DATA is missing or empty. Make sure horses.js is loaded before this script.");
    }

    const horses = HORSE_DATA.map((h, i) => ({
      name:  h.name,
      color: h.color || palette[i % palette.length],
      lane:  i + 1,
      x: 50,
      y: laneOffset + i * laneGap,
      speed: 0,
      step: 0,
      animTime: 0,
      sprite: null,
      finished: false,
      finishTime: null,
      stats: {
        baseSpeed:  Number(h.baseSpeed),
        stamina:    Number(h.stamina),
        sprint:     Number(h.sprint),
        variance:   Number(h.variance),
        fatigue:    Number(h.fatigue),
        kick:       Number(h.kick),
        finalBoost: Number(h.finalBoost)
      }
    }));

    // Frames/Scale UI
    const framesInput = document.getElementById('framesInput');
    const scaleInput  = document.getElementById('scaleInput');
    framesInput.value = SPRITE_FRAMES_DEFAULT;
    scaleInput.value  = SPRITE_SCALE_DEFAULT;
    framesInput.oninput = () => { spriteConfig.frames = Math.max(2, Math.min(32, +framesInput.value||SPRITE_FRAMES_DEFAULT)); };
    scaleInput.oninput  = () => { spriteConfig.scale  = Math.max(0.2, Math.min(4, +scaleInput.value||SPRITE_SCALE_DEFAULT)); };

    // Track drawing
    // Track drawing with realistic racing elements
    
function drawTrack() {
  // Use colors from TRACK_STYLE or fallback to defaults
  const topColor = window.TRACK_STYLE?.backgroundTop || '#D2B48C';
  const bottomColor = window.TRACK_STYLE?.backgroundBottom || '#C19A6B';
  
  // Draw gradient background
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, topColor);
  gradient.addColorStop(1, bottomColor);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, worldWidth, canvas.height);

  // === INNER RAIL (top border) ===
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, laneOffset - laneGap/2 - 8, worldWidth, 8);
  // Rail posts
  for (let x = 0; x < worldWidth; x += 80) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(x, laneOffset - laneGap/2 - 12, 6, 16);
  }

  // === OUTER RAIL (bottom border) ===
  const outerRailY = laneOffset - laneGap/2 + horses.length * laneGap;
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, outerRailY, worldWidth, 8);
  // Rail posts
  for (let x = 0; x < worldWidth; x += 80) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(x, outerRailY - 4, 6, 16);
  }

  // === STARTING GATE ===
  const gateX = 30;
  const gateWidth = 15;
  
  // Gate frame
  ctx.fillStyle = '#4A4A4A';
  ctx.fillRect(gateX - 5, laneOffset - laneGap/2 - 10, 5, outerRailY - (laneOffset - laneGap/2) + 20);
  ctx.fillRect(gateX + gateWidth, laneOffset - laneGap/2 - 10, 5, outerRailY - (laneOffset - laneGap/2) + 20);
  
  // Individual stall gates
  for (let i = 0; i < horses.length; i++) {
    const stallY = laneOffset - laneGap/2 + i * laneGap;
    
    // Stall divider
    ctx.fillStyle = '#666';
    ctx.fillRect(gateX - 5, stallY + laneGap - 2, gateWidth + 10, 3);
    
    // Gate door (closed before race, open during)
    if (!raceActive && !raceFinished) {
      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      ctx.fillRect(gateX, stallY, gateWidth, laneGap - 3);
      
      // Gate bars
      for (let b = 0; b < 4; b++) {
        ctx.fillStyle = '#888';
        ctx.fillRect(gateX + b * 4, stallY, 2, laneGap - 3);
      }
    }
    
    // Lane number on gate
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(i + 1, gateX + gateWidth/2, stallY + laneGap/2 + 6);
  }

  // === LANE DIVIDERS (white dashed lines) ===
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 5]);
  for (let i = 1; i < horses.length; i++) {
    ctx.beginPath();
    ctx.moveTo(0, laneOffset - laneGap/2 + i * laneGap);
    ctx.lineTo(worldWidth, laneOffset - laneGap/2 + i * laneGap);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // === FURLONG MARKERS ===
  const FURLONGS_TOTAL = 8;
  for (let f = 1; f <= FURLONGS_TOTAL; f++) {
    const x = 50 + (finishLine - 50) * (f / FURLONGS_TOTAL);
    
    ctx.save();
    // Marker pole
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.moveTo(x, laneOffset - laneGap / 2);
    ctx.lineTo(x, outerRailY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Furlong pole top
    ctx.fillStyle = '#fff';
    ctx.fillRect(x - 3, laneOffset - laneGap / 2 - 20, 6, 16);
    
    // Furlong number
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#0066cc';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
    ctx.fillText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
    ctx.restore();
  }

  // === FINISH LINE ===
  const finishWidth = 35;
  
  // Red finish post
  ctx.fillStyle = '#CC0000';
  ctx.fillRect(finishLine - 3, 0, 6, canvas.height);
  
  // Checkered pattern
  const checkerSize = 20;
  for (let y = 0; y < canvas.height; y += checkerSize) {
    for (let x = 0; x < finishWidth; x += checkerSize) {
      const isBlack = ((x / checkerSize) + (y / checkerSize)) % 2 === 0;
      ctx.fillStyle = isBlack ? '#000' : '#fff';
      ctx.fillRect(finishLine + 3, y, checkerSize, checkerSize);
      ctx.fillRect(finishLine + 3 + checkerSize, y, checkerSize, checkerSize);
    }
  }
  
  // Finish line banner
  ctx.fillStyle = 'rgba(204, 0, 0, 0.9)';
  ctx.fillRect(finishLine - 20, 10, finishWidth + 40, 35);
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 24px Arial';
  ctx.textAlign = 'center';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4;
  ctx.strokeText('FINISH', finishLine + finishWidth/2 - 10, 32);
  ctx.fillText('FINISH', finishLine + finishWidth/2 - 10, 32);

  // === DISTANCE MARKERS ON TRACK ===
  // Starting line
  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.fillRect(48, laneOffset - laneGap/2, 4, outerRailY - (laneOffset - laneGap/2));
}
  






// Sprite drawing with proper color tinting
function drawHorseSprite(horse, dt) {
  const { frames, scale, fps } = spriteConfig;
  const hasSprite = horse.sprite && horse.sprite.img && horse.sprite.img.complete;

  function drawName(yOffset){
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 4;
    ctx.strokeText(horse.name, 0, yOffset);
    ctx.fillStyle = '#fff';
    ctx.fillText(horse.name, 0, yOffset);
  }

  // Use default sprite if present
  if (!hasSprite && horseSprite.complete) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    const animFps = fps + horse.speed * 0.6;
    horse.animTime = (horse.animTime || 0) + animFps * dt;
    const frameWidth  = horseSprite.width / SPRITE_FRAMES_DEFAULT;
    const frameHeight = horseSprite.height;
    const frame       = Math.floor(horse.animTime) % SPRITE_FRAMES_DEFAULT;
    const drawWidth  = frameWidth  * SPRITE_SCALE_DEFAULT;
    const drawHeight = frameHeight * SPRITE_SCALE_DEFAULT;
    
    // Create temporary canvas for tinting
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = drawWidth;
    tempCanvas.height = drawHeight;
    
    // Draw horse to temp canvas
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    // Apply color tint using multiply blend
    tempCtx.globalCompositeOperation = 'multiply';
    tempCtx.fillStyle = horse.color;
    tempCtx.fillRect(0, 0, drawWidth, drawHeight);
    
    // Restore original alpha channel (removes background tinting)
    tempCtx.globalCompositeOperation = 'destination-in';
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    tempCtx.globalCompositeOperation = 'source-over';
    
    // Draw tinted horse
    ctx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2 - 22);
    
    drawName(-drawHeight * 0.6);
    ctx.restore();
    return;
  }

  // Fallback circle (already uses color)
  if (!hasSprite) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    ctx.fillStyle = horse.color;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(horse.lane, 0, 0);
    drawName(-30);
    ctx.restore();
    return;
  }

  // Custom sprite with color tint
  const img = horse.sprite.img;
  const frameW = Math.floor(img.width / frames);
  const frameH = img.height;
  const animFps = fps + horse.speed * 0.6;
  horse.animTime = (horse.animTime || 0) + animFps * dt;
  const frameIndex = Math.floor(horse.animTime) % frames;
  const drawW = frameW * scale;
  const drawH = frameH * scale;

  ctx.save();
  ctx.translate(horse.x, horse.y);
  
  // Create temporary canvas for tinting
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = drawW;
  tempCanvas.height = drawH;
  
  // Draw sprite frame
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  // Apply color tint
  tempCtx.globalCompositeOperation = 'multiply';
  tempCtx.fillStyle = horse.color;
  tempCtx.fillRect(0, 0, drawW, drawH);
  
  // Restore transparency
  tempCtx.globalCompositeOperation = 'destination-in';
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  tempCtx.globalCompositeOperation = 'source-over';
  
  // Draw tinted result
  ctx.drawImage(tempCanvas, -drawW*0.5, -drawH*0.5);

  drawName(-drawH * 0.6);
  ctx.restore();
}















    // Leaderboard & results
    const leaderboard = document.getElementById('leaderboard');
    const raceResults = document.getElementById('raceResults');
    const raceHistoryEl = document.getElementById('raceHistory');

  function refreshLeaderboard() {
  const sorted = [...horses].sort((a,b) => b.x - a.x);
  let html = '<h4 style="margin:8px 0">üèá Current Standings</h4>';
  sorted.forEach((h,i) => {
    const pct = Math.max(0, Math.round((h.x / finishLine) * 100));
    
    // Build race code
    let raceCode = '';
    raceHistory.forEach(race => {
      const result = race.results.find(r => r.name === h.name);
      if (result) {
        raceCode += result.position >= 10 ? '0' : result.position;
      }
    });
    const displayCode = raceCode || '----';
    
    // ADD STRATEGY BADGE
    const strategyBadge = h.strategy 
      ? `<span style="background:${getStrategyColor(h.strategy)};color:white;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px">${h.strategy}</span>`
      : '';
    
    // FIXED: Show everything in ONE div (not two!)
    html += `<div class="horse-info">
      ${i+1}. <b>${h.name}</b> ${strategyBadge} ‚Äî Lane ${h.lane} ‚Äî <span style="color:${h.color}">‚óè</span> ${pct}%
      <div class="tiny">Race history: ${displayCode}</div>
    </div>`;
  });
  leaderboard.innerHTML = html;
}

// ADD THIS HELPER FUNCTION
function getStrategyColor(strategy) {
  switch(strategy) {
    case 'FRONT_RUNNER': return '#ff4444';
    case 'PRESSER': return '#ff9800';
    case 'STALKER': return '#2196F3';
    case 'CLOSER': return '#9c27b0';
    default: return '#666';
  }
}




    function updateRaceHistory() {
      if (raceHistory.length === 0) {
        raceHistoryEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        updateCompleteStats();
        return;
      }
      
      let html = '';
      raceHistory.slice().reverse().forEach((race, idx) => {
        const actualRaceNum = raceHistory.length - idx;
        html += `<div style="background:rgba(0,0,0,0.2);padding:8px;margin:6px 0;border-radius:6px">
          <div style="font-weight:bold;margin-bottom:4px">Race #${actualRaceNum}</div>
          <div style="font-size:12px">`;
        
        race.results.forEach(r => {
          const medal = r.position === 1 ? 'ü•á' : r.position === 2 ? 'ü•à' : r.position === 3 ? 'ü•â' : '';
          html += `<div style="padding:2px 0">
            ${medal} ${r.position}. <span style="color:${r.color}">‚óè</span> ${r.name} (L${r.lane})
          </div>`;
        });
        
        html += `</div></div>`;
      });
      
      raceHistoryEl.innerHTML = html;
      updateCompleteStats();
    }

    function updateCompleteStats() {
      const completeStatsEl = document.getElementById('completeStats');
      
      if (raceHistory.length === 0) {
        completeStatsEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        return;
      }

      let html = '<div style="background:rgba(0,0,0,0.2);padding:8px;border-radius:6px">';
      
      horses.forEach(h => {
        // Build race code for this horse
        let raceCode = '';
        raceHistory.forEach(race => {
          const result = race.results.find(r => r.name === h.name);
          if (result) {
            raceCode += result.position >= 10 ? '0' : result.position;
          }
        });
        
        if (raceCode) {
          html += `<div style="padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1)">
            <span style="color:${h.color};font-size:16px">‚óè</span> 
            <b>${h.name}</b> - ${raceCode}
          </div>`;
        }
      });
      
      html += '</div>';
      completeStatsEl.innerHTML = html;
    }

    function updateRaceResults() {
      if (!raceActive && finishOrder.length === 0) {
        raceResults.style.display = 'none';
        return;
      }
      raceResults.style.display = 'block';
      let html = '<h3 style="margin:0 0 10px 0; font-size:18px;">üìä Race Results</h3>';

      if (finishOrder.length > 0) {
        finishOrder.forEach((h, i) => {
          const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
          html += `<div class="result-item">
            <span class="result-position">${i+1}${getOrdinalSuffix(i+1)}</span>
            ${medal ? `<span class="result-medal">${medal}</span>` : ''}
            <span style="color:${h.color};font-size:20px">‚óè</span>
            <span style="flex:1"><b>${h.name}</b><br/><small>Lane ${h.lane}</small></span>
          </div>`;
        });
      }

      const stillRacing = horses.filter(h => !h.finished);
      if (stillRacing.length > 0) {
        html += '<div style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.3)">';
        html += '<div style="font-size:13px;opacity:0.8;margin-bottom:6px">Still Racing:</div>';
        stillRacing.forEach(h => {
          const pct = Math.max(0, Math.min(100, Math.round((h.x / finishLine) * 100)));
          html += `<div style="padding:4px;margin:3px 0;font-size:13px">
            <span style="color:${h.color}">‚óè</span> ${h.name} - ${pct}%
          </div>`;
        });
        html += '</div>';
      }
      raceResults.innerHTML = html;
    }

    function getOrdinalSuffix(num) {
      const j = num % 10, k = num % 100;
      if (j === 1 && k !== 11) return 'st';
      if (j === 2 && k !== 12) return 'nd';
      if (j === 3 && k !== 13) return 'rd';
      return 'th';
    }

   
    // Race control
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const loadStatus = document.getElementById('loadStatus');

    function startRace() {
      if (raceActive) return;
      raceActive = true;
      raceFinished = false;
      finishOrder = [];
      horses.forEach(h => {
        h.finished = false;
        h.finishTime = null;
        h._lateKickUsed = false;
        h._finalBoostUsed = false;
        h._kickTimer = 0;
        h._kickCooldown = 0;
      });

      assignRacingStrategies(horses); // ‚≠ê ADD THIS LINE

      startBtn.disabled = true;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'block';
      lastTs = performance.now();
    }

    function resetRace() {
      raceActive = false;
      raceFinished = false;
      cameraX = 0;
      finishOrder = [];
      horses.forEach(h=>{
        h.x=50; h.speed=0; h.step=0; h.animTime=0;
        h.y = laneOffset + (h.lane-1)*laneGap;
        h._kickTimer = 0;
        h._kickCooldown = 0;
        h._finalBoostUsed = false;
        h._lateKickUsed = false;
        h.finished = false;
        h.finishTime = null;
      });
      startBtn.disabled = false;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'none';
      refreshLeaderboard();
    }



// ============================================
// UPDATE YOUR updateHorses() FUNCTION:
// Replace the physics calculation part with this
// ============================================

function updateHorses(dt) {
  if (!raceActive) return;

  // Precompute leader once per tick
  const leaderXGlobal = Math.max(...horses.map(hh => hh.x));

  horses.forEach(h => {
    const prog = Math.min(1, (h.x - 50) / (finishLine - 50)); // 0..1 race progress

    // --- Phase pacing (uses strategyParams + kickPhase) ---
    const sp = h.strategyParams || {};
    const earlyPace = sp.earlyPace ?? 0.9;
    const midPace   = sp.midPace   ?? 0.9;
    const latePace  = sp.latePace  ?? 0.95;
    const kickPhase = sp.kickPhase ?? 0.80;

    let paceTarget;
    if (prog < 0.33) {
      paceTarget = earlyPace;
    } else if (prog < Math.min(0.70, kickPhase)) {
      paceTarget = midPace;
    } else if (prog >= kickPhase) {
      paceTarget = latePace; // KICK phase
    } else {
      paceTarget = midPace;
    }

    // --- Base speed with strategy phase ---
    const baseSpeed = h.stats.baseSpeed * paceTarget;

    // --- Stamina effect (ramps up with distance) ---
    // Slightly gentler exponent for smoother degradation
    const staminaEffect = Math.pow(h.stats.stamina, 1.8 * prog);

    // --- Fatigue/pressure from leading (leader pays a tax) ---
    const isLeading = h.x >= leaderXGlobal - 5;
    const energyDrain = sp.energyDrain ?? 1.1;
    // Start applying leader pressure around halfway; scale with prog
    const tired = 1 - h.stats.fatigue * Math.max(0, prog - 0.5) * (isLeading ? energyDrain : 1.0);

    // --- Random variance (soft-capped to keep packs tight) ---
    const rawJitter = (Math.random() - 0.5) * (h.stats.variance ?? 0.1);
    const jitter = Math.max(-0.08, Math.min(0.08, rawJitter)); // clamp ¬±0.08

    // --- Initial speed before kick/surge logic ---
    let s = baseSpeed * staminaEffect * tired + jitter;

    // --- Kick bursts (your existing logic, kept) ---
    if (h._kickCooldown == null) h._kickCooldown = 0;
    if (h._kickTimer == null)    h._kickTimer    = 0;
    h._kickCooldown -= dt;
    h._kickTimer = Math.max(0, h._kickTimer - dt);

    if (h._kickCooldown <= 0 && Math.random() < 0.015 * h.stats.kick) {
      h._kickTimer = 0.6 + 0.8 * h.stats.kick;
      h._kickCooldown = 2.0 + Math.random() * 2.0;
    }

    if (prog > 0.82 && h._kickTimer === 0 && !h._lateKickUsed) {
      h._kickTimer = 0.7 + 0.9 * h.stats.kick;
      h._lateKickUsed = true;
    }

    const kickBoost = h._kickTimer > 0
      ? 1 + (0.20 + 0.80 * h.stats.kick) * (1 - prog * 0.3)
      : 1;
    s *= kickBoost;

    // --- STALKER mid/late awareness (catch-up + drafting + steady late) ---
    if (h.strategy === 'STALKER') {
      const behindPx = leaderXGlobal - h.x;

      // convert pixels to "lengths" (heuristic)
      const oneLengthPx = Math.max(1, (h.stats.baseSpeed || 1) * 12);
      const gapLengths = behindPx / oneLengthPx;

      // (A) Proportional mid-race catch-up (up to +8%)
      if (prog > 0.28 && prog < 0.74 && gapLengths > 0.8) {
        // base + scaled by how far back; capped
        const gain = Math.min(0.08, 0.02 + 0.03 * (gapLengths - 0.8));
        s *= (1 + gain);
      }

      // (B) Drafting bonus when within ~1‚Äì3 lengths of any horse ahead
      //     (helps them "stick" to the pack)
      const nearestAheadPx = horses.reduce((min, o) => {
        if (o === h || o.x <= h.x) return min;
        const d = o.x - h.x;
        return d < min ? d : min;
      }, Infinity);
      if (nearestAheadPx < 3 * oneLengthPx) {
        s *= 1.03; // small aero/pressure benefit
      }

      // (C) Reliable late steadiness
      if (prog > 0.80) {
        s *= 1.05;
      }

      // (D) Mid-late fatigue guard (keeps them from sagging too hard)
      if (prog > 0.55 && prog < 0.85) {
        s *= 1.02;
      }
    }



    // --- PRESSER late surge (gap-aware) ---
    if (h.strategy === 'PRESSER') {
      const surgeWindow  = sp.surgeWindow ?? 0.18; // last 18% of race
      const gapTrigger   = sp.gapTrigger  ?? 0.6;  // lengths behind before surge assist
      const kickMult     = sp.kickMult    ?? 1.12; // base kick multiplier for pressers

      // Start building earlier for pressers
      if (prog >= (sp.kickPhase ?? 0.70)) {
        s *= kickMult;

        // If still behind in final surge window, add capped catch-up
        if (prog >= (1 - surgeWindow)) {
          // convert px gap to "lengths"
          const gapPx = leaderXGlobal - h.x;
          const oneLengthPx = Math.max(1, (h.stats.baseSpeed || 1) * 12); // heuristic
          const gapLengths = gapPx / oneLengthPx;

          if (gapLengths > gapTrigger) {
            // smooth, bounded catch-up: stronger if farther back, capped
            const catchUp = Math.min(1.12, 1 + 0.06 * Math.tanh(gapLengths - gapTrigger));
            s *= catchUp;
          }
        }
      }
    }

    // --- Final boost for closers in last 10% (your logic, kept) ---
    if (!h._finalBoostUsed && prog > 0.9 && h.strategy === 'CLOSER') {
      s *= h.stats.finalBoost * 1.2;
      h._finalBoostUsed = true;
    }
    if (h._finalBoostUsed && prog > 0.9) {
      s *= 1.0 - (prog - 0.9) * 0.3; // taper off
    }

    // --- Safety floors & motion ---
    h.speed = Math.max(0.8, s);
    h.x += h.speed;
    h.step += h.speed * 0.08;

    // --- Finish detection (unchanged) ---
    if (h.x >= finishLine && !h.finished) {
      h.finished = true;
      h.finishTime = performance.now();
      finishOrder.push({
        name: h.name,
        lane: h.lane,
        color: h.color,
        position: finishOrder.length + 1,
        strategy: h.strategy
      });

      if (finishOrder.length === horses.length) {
        raceFinished = true;
        raceActive = false;
        showResults();
      }
    }

    if (h.finished && h.x > finishLine + 100) {
      h.speed *= 0.95;
    }
  });

  refreshLeaderboard();
  updateRaceResults();
}








    function shuffleLanes() {
      const ids = horses.map((_, i) => i + 1).sort(() => Math.random() - 0.5);
      horses.forEach((h,i) => {
        h.lane = ids[i];
        h.y = laneOffset + (h.lane-1)*laneGap;
      });
      refreshLeaderboard();
    }

    function showResults() {
      const el = document.getElementById('winner');
      let html = `<div style="font-size:28px; margin-bottom:16px;">üèÜ RACE COMPLETE üèÜ</div>`;
      html += '<div style="text-align:left;">';
      finishOrder.forEach((h, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
        html += `<div style="margin:10px 0; font-size:${22-i*1.5}px; padding:8px; background:rgba(139,69,19,0.3); border-radius:6px;">
          ${medal} <b>${i+1}${getOrdinalSuffix(i+1)}</b> - <span style="color:${h.color}">‚óè</span> ${h.name} <small style="opacity:0.8">(Lane ${h.lane})</small>
        </div>`;
      });
      html += '</div>';
      el.innerHTML = html;
      el.style.display = 'block';
      resetBtn.disabled = false;
      startBtn.disabled = true;
      
      // Save race to history
      raceNumber++;
      raceHistory.push({
        raceNum: raceNumber,
        results: finishOrder.map((h, i) => ({
          position: i + 1,
          name: h.name,
          lane: h.lane,
          color: h.color
        }))
      });
      updateRaceHistory();
      refreshLeaderboard(); // Update to show new "last race" positions
      saveRaceHistory(); // Save to storage
    }

    function refreshButtonsIfLoaded() {
      const allReady = horseSprite.complete || horses.some(h => h.sprite?.img?.complete);
      startBtn.disabled   = !allReady;
      resetBtn.disabled   = true;
      loadStatus.textContent = allReady ? "Sprites loaded. Ready to race!" : "Loading sprites‚Ä¶";
    }
    horseSprite.onload = refreshButtonsIfLoaded;

    // Game loop with camera tracking
    let lastTs = performance.now();
    function loop(ts) {
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;

      if (raceActive || raceFinished) {
        const leader = Math.max(...horses.map(h => h.x));
        const targetCameraX = Math.max(0, Math.min(worldWidth - canvas.width, leader - canvas.width * 0.3));
        cameraX += (targetCameraX - cameraX) * 0.1;
      }

      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(-cameraX, 0);

      drawTrack();
      horses.slice().sort((a,b)=>a.y-b.y).forEach(h => drawHorseSprite(h, dt));

      ctx.restore();

      updateHorses(dt);
      requestAnimationFrame(loop);
    }

    // Buttons
    startBtn.onclick = startRace;
    resetBtn.onclick = resetRace;
        
    document.getElementById('clearHistoryBtn').onclick = () => {
      if (confirm('Clear all race history?')) {
        raceHistory = [];
        raceNumber = 0;
        updateRaceHistory();
        refreshLeaderboard();
        saveRaceHistory(); // Save cleared state
      }
    };


// Dynamic Strategy Assignment System
// Assigns strategies based on how each horse compares to the AVERAGE of the race field

// Dynamic Strategy Assignment System - BALANCED VERSION
// Ensures all 4 strategies exist and performs well

function assignRacingStrategies(horses) {
  // Calculate average stats for this race
  const avgBaseSpeed = horses.reduce((sum, h) => sum + h.stats.baseSpeed, 0) / horses.length;
  const avgStamina = horses.reduce((sum, h) => sum + h.stats.stamina, 0) / horses.length;
  const avgSprint = horses.reduce((sum, h) => sum + h.stats.sprint, 0) / horses.length;
  
  const raceLength = finishLine - 50;
  const isShortRace = raceLength < 3000;
  const isLongRace = raceLength > 6000;

  console.log('üèÅ Race Distance:', raceLength, isShortRace ? '(SHORT)' : isLongRace ? '(LONG)' : '(MEDIUM)');
  console.log('üèÅ Race Field Averages:', {
    baseSpeed: avgBaseSpeed.toFixed(2),
    stamina: avgStamina.toFixed(2),
    sprint: avgSprint.toFixed(2)
  });
  
  // STEP 1: Score each horse for each strategy
  const strategyScores = horses.map(horse => {
    const speedRatio = horse.stats.baseSpeed / avgBaseSpeed;
    const staminaRatio = horse.stats.stamina / avgStamina;
    const sprintRatio = horse.stats.sprint / avgSprint;
    
    return {
      horse: horse,
      scores: {
        FRONT_RUNNER: speedRatio * 1.5 + staminaRatio * 0.8 - sprintRatio * 0.3,
        PRESSER: speedRatio * 1.2 + staminaRatio * 1.2 + sprintRatio * 0.8,
        STALKER: Math.abs(speedRatio - 1) * -2 + Math.abs(staminaRatio - 1) * -2 + Math.abs(sprintRatio - 1) * -2 + 3, // Favors balanced
        CLOSER: sprintRatio * 1.5 + staminaRatio * 1.0 - speedRatio * 0.5
      }
    };
  });

  // STEP 2: Force distribution - ensure all 4 strategies exist
  const minPerStrategy = Math.floor(horses.length / 4); // At least 1/4 of horses per strategy
  const strategies = ['FRONT_RUNNER', 'PRESSER', 'STALKER', 'CLOSER'];
  const assigned = new Map();
  const usedHorses = new Set();
  
  // Assign best-fit horses to each strategy (minimum quota)
  strategies.forEach(strat => {
    const sorted = strategyScores
      .filter(s => !usedHorses.has(s.horse))
      .sort((a, b) => b.scores[strat] - a.scores[strat]);
    
    for (let i = 0; i < minPerStrategy && i < sorted.length; i++) {
      assigned.set(sorted[i].horse, strat);
      usedHorses.add(sorted[i].horse);
    }
  });
  
  // Assign remaining horses to their best-fit strategy
  strategyScores.forEach(s => {
    if (!usedHorses.has(s.horse)) {
      const bestStrat = Object.entries(s.scores)
        .sort((a, b) => b[1] - a[1])[0][0];
      assigned.set(s.horse, bestStrat);
    }
  });

  // STEP 3: Apply BALANCED strategy parameters
  horses.forEach(horse => {
    const strategy = assigned.get(horse);
    horse.strategy = strategy;
    
    const speedRatio = horse.stats.baseSpeed / avgBaseSpeed;
    const staminaRatio = horse.stats.stamina / avgStamina;
    const sprintRatio = horse.stats.sprint / avgSprint;
    
    console.log(`\nüê¥ ${horse.name}: ${strategy}`, {
      speedRatio: speedRatio.toFixed(2),
      staminaRatio: staminaRatio.toFixed(2),
      sprintRatio: sprintRatio.toFixed(2)
    });
    
    switch(strategy) {
      case 'FRONT_RUNNER':
        horse.strategyParams = {
          earlyPace: isShortRace ? 0.98 : 0.93,    // Reduced from 1.0/0.95
          midPace: 0.88,                            // Increased from 0.75-0.85
          latePace: 0.82,                           // Increased from 0.65-0.75
          energyDrain: 1.15,                        // Reduced from 1.3-1.5
          kickPhase: 0.85                           // Kick earlier
        };
        break;
        
      case 'PRESSER':
        // NERFED - was too strong
        const latePace = 1.00 + Math.min(0.06, 0.03*(sprintRatio-1) + 0.02*(staminaRatio-1)); // Was 1.06-1.16
        const kickMult = Math.min(1.10, 1.05 + 0.04*(sprintRatio-1) + 0.03*(staminaRatio-1)); // Was 1.10-1.22
        
        horse.strategyParams = {
          earlyPace: 0.82,                          // Increased from 0.78
          midPace: 0.90,                            // Increased from 0.88
          latePace: latePace,                       // Reduced multipliers
          energyDrain: 1.08,                        // Increased from 1.02
          kickPhase: 0.72,                          // Slightly later
          kickMult: kickMult,                       // Reduced
          surgeWindow: 0.15,                        // Reduced from 0.18
          gapTrigger: 0.8                           // Harder to trigger (was 0.6)
        };
        break;
        
      case 'CLOSER':
        horse.strategyParams = {
          earlyPace: isShortRace ? 0.78 : 0.70,    // Increased from 0.75/0.65
          midPace: 0.76,                            // Increased from 0.70
          latePace: isLongRace ? 1.30 : 1.22,      // Slightly reduced
          energyDrain: 0.75,                        // Slightly increased
          kickPhase: isShortRace ? 0.75 : 0.82     // Balanced timing
        };
        break;
        
      case 'STALKER':
        horse.strategyParams = {
          earlyPace: 0.80,                          // Increased from 0.75
          midPace: 0.88,                            // Increased from 0.85
          latePace: 1.08,                           // Increased from 1.05
          energyDrain: 0.95,                        // Reduced from 1.0
          kickPhase: 0.72                           // Slightly later
        };
        break;
    }
  });
  
  // Log strategy distribution
  const stratCounts = {};
  horses.forEach(h => {
    stratCounts[h.strategy] = (stratCounts[h.strategy] || 0) + 1;
  });
  console.log('\nüìä Strategy Distribution:', stratCounts);
}








    // Download racehistory.js
    document.getElementById('downloadRaceHistoryBtn').onclick = () => {
      const jsContent = `// Race History Data
// This file stores all completed race results

window.RACE_HISTORY_DATA = {
  raceNumber: ${raceNumber},
  races: ${JSON.stringify(raceHistory, null, 2)}
};
`;

      const blob = new Blob([jsContent], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'racehistory.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('racehistory.js downloaded! Add this line to your HTML before the main script tag.');
    };

 

    // Toggle UI visibility
    const toggleUIBtn = document.getElementById('toggleUI');
    const uiPanel = document.getElementById('ui');
    uiPanel.classList.add('hidden'); // start hidden
    
    toggleUIBtn.onclick = () => {
      uiPanel.classList.toggle('hidden');
      toggleUIBtn.textContent = uiPanel.classList.contains('hidden') ? 'Show Settings ‚öôÔ∏è' : 'Hide Settings ‚öôÔ∏è';
    };

    // Kick off
    loadRaceHistory(); // Load saved history
    refreshButtonsIfLoaded();
    refreshLeaderboard();
    updateRaceHistory();
    requestAnimationFrame(loop);
  </script>
</body>
</html>