<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Horse Racing (Sprite Sheet)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:linear-gradient(#87CEEB,#98D98E);overflow:hidden}
    #gameCanvas{display:block;margin:20px auto;background:linear-gradient(#7CB342,#558B2F);border:5px solid #8B4513;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #ui{
      position:absolute;top:20px;left:20px;background:rgba(139,69,19,.92);
      color:#fff;padding:14px;border-radius:10px;min-width:320px;max-width:380px;
      max-height:80vh;overflow-y:auto;z-index:100
    }
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{min-width:64px;font-size:13px}
    .row input[type="text"], .row input[type="number"]{
      flex:1;border:none;border-radius:6px;padding:6px 8px;outline:none;font-size:13px
    }
    .row input[type="file"]{flex:1}
    .tiny{font-size:12px;opacity:.9}
    .horse-info{background:rgba(0,0,0,.25);padding:6px 8px;border-radius:6px;margin:8px 0}
    #controls{
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      background:rgba(139,69,19,.92);color:#fff;border-radius:10px;padding:14px 16px;
      display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center
    }
    button{
      background:#4CAF50;color:#fff;border:none;border-radius:6px;padding:10px 18px;
      cursor:pointer;transition:.2s;font-size:15px
    }
    button:hover{background:#45a049;transform:scale(1.05)}
    button:disabled{background:#666;transform:none;cursor:not-allowed}
    #winner{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(255,215,0,.96);padding:28px;border-radius:14px;font-weight:700;
      color:#8B4513;display:none;text-align:center;font-size:22px;box-shadow:0 0 40px rgba(255,215,0,.8);
      max-height:70vh;overflow-y:auto;max-width:500px
    }
    #raceResults{
      position:absolute;top:100px;right:20px;background:rgba(139,69,19,.95);
      color:#fff;padding:16px;border-radius:10px;min-width:280px;
      display:none;z-index:100;box-shadow:0 5px 20px rgba(0,0,0,.4)
    }
    .result-item{
      padding:8px;margin:6px 0;background:rgba(0,0,0,.3);border-radius:6px;
      display:flex;align-items:center;gap:10px;font-size:15px
    }
    .result-position{font-weight:bold;font-size:20px;min-width:35px;text-align:center}
    .result-medal{font-size:24px}
    #loadStatus{margin-left:10px;font-size:13px}
    #toggleUI{
      position:absolute;top:20px;right:20px;background:#4CAF50;color:#fff;
      border:none;border-radius:6px;padding:10px 18px;cursor:pointer;
      transition:.2s;font-size:15px;z-index:101
    }
    #toggleUI:hover{background:#45a049}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <button id="toggleUI">Hide Settings ‚öôÔ∏è</button>

  <div id="ui">
    <h3>üèá Sprite Horse Racing</h3>

    <div class="tiny" style="margin-bottom:8px">
      This page auto-loads <b>default.jpg</b> (6 frames, one row). You can override any horse with your own PNG/JPG.
    </div>

    <div class="row">
      <label>Frames</label>
      <input id="framesInput" type="number" min="2" max="32" />
    </div>
    <div class="row">
      <label>Scale</label>
      <input id="scaleInput" type="number" min="0.2" max="4" step="0.1" />
    </div>
    <div class="tiny">Tip: If the horse looks too small/large, change <b>Scale</b>.</div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">

    <div id="horseConfig"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <div id="leaderboard"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üìú Race History</h4>
    <div id="raceHistory" style="max-height:200px;overflow-y:auto"></div>
    <button id="clearHistoryBtn" style="margin-top:8px;font-size:12px;padding:6px 12px">Clear History</button>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üèÜ All Horses Complete Stats</h4>
    <div id="completeStats" style="max-height:250px;overflow-y:auto;font-size:12px"></div>
    
    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üíæ Export Settings</h4>
    <button id="downloadHorsesBtn" style="font-size:12px;padding:6px 12px;width:100%;margin-bottom:6px">Download horses.js</button>
    <button id="copyHorsesBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#2196F3;margin-bottom:6px">Copy horses.js Code</button>
    <button id="downloadRaceHistoryBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#FF9800;margin-bottom:6px">Download racehistory.js</button>
    <button id="copyRaceHistoryBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#FF5722">Copy racehistory.js Code</button>
    <div class="tiny" style="margin-top:6px;opacity:0.7">Download or copy current horse stats and race history. Save as .js files and link in HTML.</div>
  </div>

  <div id="controls">
    <button id="startBtn" disabled>Start Race</button>
    <button id="resetBtn" disabled>Reset Race</button>
    <button id="shuffleBtn" disabled>Shuffle Lanes</button>
    <span id="loadStatus" class="tiny">Loading sprites‚Ä¶</span>
  </div>

  <div id="winner"></div>
  <div id="raceResults"></div>

  <!-- Your horse stats -->
  <script src="horses.js"></script>
	
  <script src="race_params.js"></script>


  <script>
    /* ---------- SPRITE SETTINGS ---------- */
    const SPRITE_SRC_DEFAULT = "default.jpg";
    const SPRITE_FRAMES_DEFAULT = 6;
    const SPRITE_SCALE_DEFAULT  = 1.0;
    /* ------------------------------------ */

// Canvas & world
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Use params from race_params.js if available, otherwise defaults
const PARAMS = window.RACE_PARAMS || {cw:1200, ch:600, ww:5000, lg:10, lo:100, fl:4500};

canvas.width = PARAMS.cw;
canvas.height = PARAMS.ch;
const worldWidth = PARAMS.ww;
const laneGap = PARAMS.lg;
const laneOffset = PARAMS.lo;
const finishLine = PARAMS.fl;

console.log("üèá Using parameters:", PARAMS);

// Display parameters on screen
const paramInfo = document.createElement('div');
paramInfo.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:lime;padding:10px;border-radius:8px;font-family:monospace;font-size:12px;z-index:9999';
paramInfo.innerHTML = `‚öôÔ∏è Race Parameters:<br>World: ${worldWidth}px | Finish: ${finishLine}px<br>Canvas: ${canvas.width}x${canvas.height} | Lane Gap: ${laneGap}`;
document.body.appendChild(paramInfo);
setTimeout(() => paramInfo.remove(), 5000);


    let raceActive = false;
    let raceFinished = false;
    let cameraX = 0;
    let finishOrder = [];
    let raceHistory = []; // Store all race results
    let raceNumber = 0;

    // Load race history from racehistory.js if available
    if (window.RACE_HISTORY_DATA) {
      raceHistory = window.RACE_HISTORY_DATA.races || [];
      raceNumber = window.RACE_HISTORY_DATA.raceNumber || 0;
      console.log('Loaded race history from racehistory.js:', raceHistory.length, 'races');
    }

    // Load race history from storage on startup
    async function loadRaceHistory() {
      // Skip loading from storage if racehistory.js was already loaded
      if (window.RACE_HISTORY_DATA) {
        updateRaceHistory();
        refreshLeaderboard();
        return;
      }
      
      try {
        // Try Claude.ai storage first
        if (window.storage) {
          const result = await window.storage.get('horse-race-history');
          if (result && result.value) {
            const data = JSON.parse(result.value);
            raceHistory = data.races || [];
            raceNumber = data.raceNumber || 0;
            console.log('Loaded race history from Claude storage:', raceHistory.length, 'races');
            updateRaceHistory();
            refreshLeaderboard();
            return;
          }
        }
      } catch (error) {
        console.log('Claude storage not available, trying localStorage');
      }
      
      // Fallback to localStorage
      try {
        const stored = localStorage.getItem('horse-race-history');
        if (stored) {
          const data = JSON.parse(stored);
          raceHistory = data.races || [];
          raceNumber = data.raceNumber || 0;
          console.log('Loaded race history from localStorage:', raceHistory.length, 'races');
          updateRaceHistory();
          refreshLeaderboard();
        }
      } catch (error) {
        console.log('No previous race history found');
      }
    }

    // Save race history to storage
    async function saveRaceHistory() {
      const data = JSON.stringify({
        races: raceHistory,
        raceNumber: raceNumber
      });
      
      // Try Claude.ai storage
      try {
        if (window.storage) {
          await window.storage.set('horse-race-history', data);
          console.log('Race history saved to Claude storage');
        }
      } catch (error) {
        console.log('Claude storage not available');
      }
      
      // Always save to localStorage as backup
      try {
        localStorage.setItem('horse-race-history', data);
        console.log('Race history saved to localStorage');
      } catch (error) {
        console.error('Failed to save race history:', error);
      }
    }

    // Shared sprite config
    const spriteConfig = {
      frames: SPRITE_FRAMES_DEFAULT,
      scale:  SPRITE_SCALE_DEFAULT,
      fps:    14
    };

    // Preload the default sprite
    const horseSprite = new Image();
    horseSprite.src = SPRITE_SRC_DEFAULT;

    // Fallback colors
    const palette = [
      "#8B0000","#FFD700","#4169E1","#FF4500","#2F4F4F","#32CD32","#9932CC","#FF69B4",
      "#00CED1","#D2691E","#E6E6FA","#DC143C","#708090","#FF6347","#9ACD32","#8A2BE2",
      "#00FA9A","#FFDAB9","#FF8C00","#1E90FF","#A0522D","#ADFF2F","#00BFFF","#20B2AA"
    ];

    if (!Array.isArray(window.HORSE_DATA) || HORSE_DATA.length === 0) {
      throw new Error("HORSE_DATA is missing or empty. Make sure horses.js is loaded before this script.");
    }

    const horses = HORSE_DATA.map((h, i) => ({
      name:  h.name,
      color: h.color || palette[i % palette.length],
      lane:  i + 1,
      x: 50,
      y: laneOffset + i * laneGap,
      speed: 0,
      step: 0,
      animTime: 0,
      sprite: null,
      finished: false,
      finishTime: null,
      stats: {
        baseSpeed:  Number(h.baseSpeed),
        stamina:    Number(h.stamina),
        sprint:     Number(h.sprint),
        variance:   Number(h.variance),
        fatigue:    Number(h.fatigue),
        kick:       Number(h.kick),
        finalBoost: Number(h.finalBoost)
      }
    }));

    // Build per-horse config panel
    const horseConfigEl = document.getElementById('horseConfig');
    function makeHorseRow(h) {
      const wrap = document.createElement('div');
      wrap.className = 'horse-info';

      wrap.innerHTML = `
        <div class="row">
          <label>Lane ${h.lane}</label>
          <input type="text" class="nm" value="${h.name}">
          <input type="text" class="hex" value="${h.color}" title="Color (badge)">
        </div>
        <div class="row">
          <label>Sprite</label>
          <input type="file" class="file" accept="image/png,image/webp,image/jpeg">
        </div>
      `;

      const statsHtml = document.createElement('div');
      statsHtml.innerHTML = `
        <div class="row"><label>Base</label>
          <input type="number" step="0.1" class="base" value="${h.stats.baseSpeed}">
          <label>Stam</label>
          <input type="number" step="0.05" class="stam" value="${h.stats.stamina}">
        </div>
        <div class="row"><label>Sprint</label>
          <input type="number" step="0.05" class="sprint" value="${h.stats.sprint}">
          <label>Var</label>
          <input type="number" step="0.05" class="var" value="${h.stats.variance}">
        </div>
        <div class="row"><label>Fatigue</label>
          <input type="number" step="0.05" class="fat" value="${h.stats.fatigue}">
        </div>
        <div class="row"><label>Kick</label>
          <input type="number" step="0.05" min="0" max="1" class="kick" value="${h.stats.kick}">
        </div>
        <div class="row"><label>Final</label>
          <input type="number" step="0.05" min="1" max="2" class="fboost" value="${h.stats.finalBoost}">
        </div>
      `;
      wrap.appendChild(statsHtml);

      wrap.querySelector('.nm').onchange = e => { h.name = e.target.value.trim() || h.name; refreshLeaderboard(); };
      wrap.querySelector('.hex').onchange = e => { h.color = e.target.value.trim() || h.color; refreshLeaderboard(); };

      statsHtml.querySelector('.base').oninput   = e => h.stats.baseSpeed = +e.target.value || h.stats.baseSpeed;
      statsHtml.querySelector('.stam').oninput   = e => h.stats.stamina   = +e.target.value || h.stats.stamina;
      statsHtml.querySelector('.sprint').oninput = e => h.stats.sprint    = +e.target.value || h.stats.sprint;
      statsHtml.querySelector('.var').oninput    = e => h.stats.variance  = +e.target.value || h.stats.variance;
      statsHtml.querySelector('.fat').oninput    = e => h.stats.fatigue   = +e.target.value || h.stats.fatigue;
      statsHtml.querySelector('.kick').oninput   = e => h.stats.kick      = +e.target.value || h.stats.kick;
      statsHtml.querySelector('.fboost').oninput = e => h.stats.finalBoost= +e.target.value || h.stats.finalBoost;

      wrap.querySelector('.file').onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { h.sprite = { img, url }; refreshButtonsIfLoaded(); };
        img.src = url;
      };

      return wrap;
    }
    horses.forEach(h => horseConfigEl.appendChild(makeHorseRow(h)));

    // Frames/Scale UI
    const framesInput = document.getElementById('framesInput');
    const scaleInput  = document.getElementById('scaleInput');
    framesInput.value = SPRITE_FRAMES_DEFAULT;
    scaleInput.value  = SPRITE_SCALE_DEFAULT;
    framesInput.oninput = () => { spriteConfig.frames = Math.max(2, Math.min(32, +framesInput.value||SPRITE_FRAMES_DEFAULT)); };
    scaleInput.oninput  = () => { spriteConfig.scale  = Math.max(0.2, Math.min(4, +scaleInput.value||SPRITE_SCALE_DEFAULT)); };

    // Track drawing
    function drawTrack() {
      ctx.fillStyle = '#558B2F';
      ctx.fillRect(0,0,worldWidth,canvas.height);

      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.setLineDash([10,5]);
      for (let i=0; i<=horses.length; i++) {
        ctx.beginPath();
        ctx.moveTo(0, laneOffset - laneGap/2 + i*laneGap);
        ctx.lineTo(worldWidth, laneOffset - laneGap/2 + i*laneGap);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Furlong markers
      const FURLONGS_TOTAL = 8;
      for (let f = 1; f <= FURLONGS_TOTAL; f++) {
        const x = 50 + (finishLine - 50) * (f / FURLONGS_TOTAL);
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.5)';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 8]);
        ctx.beginPath();
        ctx.moveTo(x, laneOffset - laneGap / 2);
        ctx.lineTo(x, laneOffset - laneGap / 2 + horses.length * laneGap);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#fff';
        ctx.fillRect(x - 2, laneOffset - laneGap / 2 - 14, 4, 10);
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.fillStyle = 'blue';
        ctx.fillText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
        ctx.restore();
      }

      // Finish line
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(finishLine, 0, 5, canvas.height);
      for (let i=0; i<canvas.height; i+=20) {
        ctx.fillStyle = (i/20)%2===0 ? 'white' : 'black';
        ctx.fillRect(finishLine+5, i, 15, 10);
        ctx.fillRect(finishLine+20, i+10, 15, 10);
      }
    }

  






// Sprite drawing with proper color tinting
function drawHorseSprite(horse, dt) {
  const { frames, scale, fps } = spriteConfig;
  const hasSprite = horse.sprite && horse.sprite.img && horse.sprite.img.complete;

  function drawName(yOffset){
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 4;
    ctx.strokeText(horse.name, 0, yOffset);
    ctx.fillStyle = '#fff';
    ctx.fillText(horse.name, 0, yOffset);
  }

  // Use default sprite if present
  if (!hasSprite && horseSprite.complete) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    const animFps = fps + horse.speed * 0.6;
    horse.animTime = (horse.animTime || 0) + animFps * dt;
    const frameWidth  = horseSprite.width / SPRITE_FRAMES_DEFAULT;
    const frameHeight = horseSprite.height;
    const frame       = Math.floor(horse.animTime) % SPRITE_FRAMES_DEFAULT;
    const drawWidth  = frameWidth  * SPRITE_SCALE_DEFAULT;
    const drawHeight = frameHeight * SPRITE_SCALE_DEFAULT;
    
    // Create temporary canvas for tinting
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = drawWidth;
    tempCanvas.height = drawHeight;
    
    // Draw horse to temp canvas
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    // Apply color tint using multiply blend
    tempCtx.globalCompositeOperation = 'multiply';
    tempCtx.fillStyle = horse.color;
    tempCtx.fillRect(0, 0, drawWidth, drawHeight);
    
    // Restore original alpha channel (removes background tinting)
    tempCtx.globalCompositeOperation = 'destination-in';
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    tempCtx.globalCompositeOperation = 'source-over';
    
    // Draw tinted horse
    ctx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2);
    
    drawName(-drawHeight * 0.6);
    ctx.restore();
    return;
  }

  // Fallback circle (already uses color)
  if (!hasSprite) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    ctx.fillStyle = horse.color;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(horse.lane, 0, 0);
    drawName(-30);
    ctx.restore();
    return;
  }

  // Custom sprite with color tint
  const img = horse.sprite.img;
  const frameW = Math.floor(img.width / frames);
  const frameH = img.height;
  const animFps = fps + horse.speed * 0.6;
  horse.animTime = (horse.animTime || 0) + animFps * dt;
  const frameIndex = Math.floor(horse.animTime) % frames;
  const drawW = frameW * scale;
  const drawH = frameH * scale;

  ctx.save();
  ctx.translate(horse.x, horse.y);
  
  // Create temporary canvas for tinting
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = drawW;
  tempCanvas.height = drawH;
  
  // Draw sprite frame
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  // Apply color tint
  tempCtx.globalCompositeOperation = 'multiply';
  tempCtx.fillStyle = horse.color;
  tempCtx.fillRect(0, 0, drawW, drawH);
  
  // Restore transparency
  tempCtx.globalCompositeOperation = 'destination-in';
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  tempCtx.globalCompositeOperation = 'source-over';
  
  // Draw tinted result
  ctx.drawImage(tempCanvas, -drawW*0.5, -drawH*0.5);

  drawName(-drawH * 0.6);
  ctx.restore();
}















    // Leaderboard & results
    const leaderboard = document.getElementById('leaderboard');
    const raceResults = document.getElementById('raceResults');
    const raceHistoryEl = document.getElementById('raceHistory');

    function refreshLeaderboard() {
      const sorted = [...horses].sort((a,b) => b.x - a.x);
      let html = '<h4 style="margin:8px 0">üèá Current Standings</h4>';
      sorted.forEach((h,i) => {
        const pct = Math.max(0, Math.round((h.x / finishLine) * 100));
        
        // Build race code: positions from all races (rightmost = latest)
        let raceCode = '';
        raceHistory.forEach(race => {
          const result = race.results.find(r => r.name === h.name);
          if (result) {
            // Use 0 for positions 10+, otherwise use the position digit
            raceCode += result.position >= 10 ? '0' : result.position;
          }
        });
        
        const displayCode = raceCode || '----';
        
        html += `<div class="horse-info">
          ${i+1}. <b>${h.name}</b> ‚Äî Lane ${h.lane} ‚Äî <span style="color:${h.color}">‚óè</span> ${pct}%
          <div class="tiny">Race history: ${displayCode}</div>
        </div>`;
      });
      leaderboard.innerHTML = html;
    }

    function updateRaceHistory() {
      if (raceHistory.length === 0) {
        raceHistoryEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        updateCompleteStats();
        return;
      }
      
      let html = '';
      raceHistory.slice().reverse().forEach((race, idx) => {
        const actualRaceNum = raceHistory.length - idx;
        html += `<div style="background:rgba(0,0,0,0.2);padding:8px;margin:6px 0;border-radius:6px">
          <div style="font-weight:bold;margin-bottom:4px">Race #${actualRaceNum}</div>
          <div style="font-size:12px">`;
        
        race.results.forEach(r => {
          const medal = r.position === 1 ? 'ü•á' : r.position === 2 ? 'ü•à' : r.position === 3 ? 'ü•â' : '';
          html += `<div style="padding:2px 0">
            ${medal} ${r.position}. <span style="color:${r.color}">‚óè</span> ${r.name} (L${r.lane})
          </div>`;
        });
        
        html += `</div></div>`;
      });
      
      raceHistoryEl.innerHTML = html;
      updateCompleteStats();
    }

    function updateCompleteStats() {
      const completeStatsEl = document.getElementById('completeStats');
      
      if (raceHistory.length === 0) {
        completeStatsEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        return;
      }

      let html = '<div style="background:rgba(0,0,0,0.2);padding:8px;border-radius:6px">';
      
      horses.forEach(h => {
        // Build race code for this horse
        let raceCode = '';
        raceHistory.forEach(race => {
          const result = race.results.find(r => r.name === h.name);
          if (result) {
            raceCode += result.position >= 10 ? '0' : result.position;
          }
        });
        
        if (raceCode) {
          html += `<div style="padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1)">
            <span style="color:${h.color};font-size:16px">‚óè</span> 
            <b>${h.name}</b> - ${raceCode}
          </div>`;
        }
      });
      
      html += '</div>';
      completeStatsEl.innerHTML = html;
    }

    function updateRaceResults() {
      if (!raceActive && finishOrder.length === 0) {
        raceResults.style.display = 'none';
        return;
      }
      raceResults.style.display = 'block';
      let html = '<h3 style="margin:0 0 10px 0; font-size:18px;">üìä Race Results</h3>';

      if (finishOrder.length > 0) {
        finishOrder.forEach((h, i) => {
          const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
          html += `<div class="result-item">
            <span class="result-position">${i+1}${getOrdinalSuffix(i+1)}</span>
            ${medal ? `<span class="result-medal">${medal}</span>` : ''}
            <span style="color:${h.color};font-size:20px">‚óè</span>
            <span style="flex:1"><b>${h.name}</b><br/><small>Lane ${h.lane}</small></span>
          </div>`;
        });
      }

      const stillRacing = horses.filter(h => !h.finished);
      if (stillRacing.length > 0) {
        html += '<div style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.3)">';
        html += '<div style="font-size:13px;opacity:0.8;margin-bottom:6px">Still Racing:</div>';
        stillRacing.forEach(h => {
          const pct = Math.max(0, Math.min(100, Math.round((h.x / finishLine) * 100)));
          html += `<div style="padding:4px;margin:3px 0;font-size:13px">
            <span style="color:${h.color}">‚óè</span> ${h.name} - ${pct}%
          </div>`;
        });
        html += '</div>';
      }
      raceResults.innerHTML = html;
    }

    function getOrdinalSuffix(num) {
      const j = num % 10, k = num % 100;
      if (j === 1 && k !== 11) return 'st';
      if (j === 2 && k !== 12) return 'nd';
      if (j === 3 && k !== 13) return 'rd';
      return 'th';
    }

    // Physics (updated)
    function updateHorses(dt) {
      if (!raceActive) return;

      horses.forEach(h => {
        const prog = Math.min(1, (h.x - 50) / (finishLine - 50));
        const startBoost  = 1 + (h.stats.sprint - 1) * Math.exp(-prog * 6);
        const staminaHold = Math.pow(h.stats.stamina, prog * 2.2);
        const tired       = 1 - h.stats.fatigue * Math.max(0, prog - 0.5);
        const jitter      = (Math.random() - 0.5) * h.stats.variance;
        let s = h.stats.baseSpeed * startBoost * staminaHold * tired + jitter;

        // Kick bursts
        if (h._kickCooldown == null) h._kickCooldown = 0;
        if (h._kickTimer    == null) h._kickTimer    = 0;
        h._kickCooldown -= dt;
        h._kickTimer     = Math.max(0, h._kickTimer - dt);

        if (h._kickCooldown <= 0 && Math.random() < 0.015 * h.stats.kick) {
          h._kickTimer    = 0.6 + 0.8 * h.stats.kick;
          h._kickCooldown = 2.0 + Math.random() * 2.0;
        }

        if (prog > 0.82 && h._kickTimer === 0 && !h._lateKickUsed) {
          h._kickTimer = 0.7 + 0.9 * h.stats.kick;
          h._lateKickUsed = true;
        }

        const kickBoost = h._kickTimer > 0
          ? 1 + (0.20 + 0.80 * h.stats.kick) * (1 - prog * 0.3)
          : 1;
        s *= kickBoost;

        // Final boost in last 10%
        if (!h._finalBoostUsed && prog > 0.9) {
          s *= h.stats.finalBoost;
          h._finalBoostUsed = true;
        }
        if (h._finalBoostUsed && prog > 0.9) {
          s *= 1.0 - (prog - 0.9) * 0.3; // fade
        }

        h.speed = Math.max(0.8, s);
        h.x += h.speed;
        h.step += h.speed * 0.08;

        // Finish recording (but allow motion after)
        if (h.x >= finishLine && !h.finished) {
          h.finished = true;
          h.finishTime = performance.now();
          finishOrder.push({
            name: h.name,
            lane: h.lane,
            color: h.color,
            position: finishOrder.length + 1
          });

          if (finishOrder.length === horses.length) {
            raceFinished = true;
            raceActive = false;
            showResults();
          }
        }

        // Gentle slowdown beyond line
        if (h.finished && h.x > finishLine + 100) {
          h.speed *= 0.95;
        }
      });

      refreshLeaderboard();
      updateRaceResults();
    }

    // Race control
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const loadStatus = document.getElementById('loadStatus');

    function startRace() {
      if (raceActive) return;
      raceActive = true;
      raceFinished = false;
      finishOrder = [];
      horses.forEach(h => {
        h.finished = false;
        h.finishTime = null;
        h._lateKickUsed = false;
        h._finalBoostUsed = false;
        h._kickTimer = 0;
        h._kickCooldown = 0;
      });
      startBtn.disabled = true;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'block';
      lastTs = performance.now();
    }

    function resetRace() {
      raceActive = false;
      raceFinished = false;
      cameraX = 0;
      finishOrder = [];
      horses.forEach(h=>{
        h.x=50; h.speed=0; h.step=0; h.animTime=0;
        h.y = laneOffset + (h.lane-1)*laneGap;
        h._kickTimer = 0;
        h._kickCooldown = 0;
        h._finalBoostUsed = false;
        h._lateKickUsed = false;
        h.finished = false;
        h.finishTime = null;
      });
      startBtn.disabled = false;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'none';
      refreshLeaderboard();
    }

    function shuffleLanes() {
      const ids = horses.map((_, i) => i + 1).sort(() => Math.random() - 0.5);
      horses.forEach((h,i) => {
        h.lane = ids[i];
        h.y = laneOffset + (h.lane-1)*laneGap;
      });
      refreshLeaderboard();
    }

    function showResults() {
      const el = document.getElementById('winner');
      let html = `<div style="font-size:28px; margin-bottom:16px;">üèÜ RACE COMPLETE üèÜ</div>`;
      html += '<div style="text-align:left;">';
      finishOrder.forEach((h, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
        html += `<div style="margin:10px 0; font-size:${22-i*1.5}px; padding:8px; background:rgba(139,69,19,0.3); border-radius:6px;">
          ${medal} <b>${i+1}${getOrdinalSuffix(i+1)}</b> - <span style="color:${h.color}">‚óè</span> ${h.name} <small style="opacity:0.8">(Lane ${h.lane})</small>
        </div>`;
      });
      html += '</div>';
      el.innerHTML = html;
      el.style.display = 'block';
      resetBtn.disabled = false;
      startBtn.disabled = true;
      
      // Save race to history
      raceNumber++;
      raceHistory.push({
        raceNum: raceNumber,
        results: finishOrder.map((h, i) => ({
          position: i + 1,
          name: h.name,
          lane: h.lane,
          color: h.color
        }))
      });
      updateRaceHistory();
      refreshLeaderboard(); // Update to show new "last race" positions
      saveRaceHistory(); // Save to storage
    }

    function refreshButtonsIfLoaded() {
      const allReady = horseSprite.complete || horses.some(h => h.sprite?.img?.complete);
      startBtn.disabled   = !allReady;
      resetBtn.disabled   = true;
      shuffleBtn.disabled = !allReady;
      loadStatus.textContent = allReady ? "Sprites loaded. Ready to race!" : "Loading sprites‚Ä¶";
    }
    horseSprite.onload = refreshButtonsIfLoaded;

    // Game loop with camera tracking
    let lastTs = performance.now();
    function loop(ts) {
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;

      if (raceActive || raceFinished) {
        const leader = Math.max(...horses.map(h => h.x));
        const targetCameraX = Math.max(0, Math.min(worldWidth - canvas.width, leader - canvas.width * 0.3));
        cameraX += (targetCameraX - cameraX) * 0.1;
      }

      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(-cameraX, 0);

      drawTrack();
      horses.slice().sort((a,b)=>a.y-b.y).forEach(h => drawHorseSprite(h, dt));

      ctx.restore();

      updateHorses(dt);
      requestAnimationFrame(loop);
    }

    // Buttons
    startBtn.onclick = startRace;
    resetBtn.onclick = resetRace;
    shuffleBtn.onclick = shuffleLanes;
    
    document.getElementById('clearHistoryBtn').onclick = () => {
      if (confirm('Clear all race history?')) {
        raceHistory = [];
        raceNumber = 0;
        updateRaceHistory();
        refreshLeaderboard();
        saveRaceHistory(); // Save cleared state
      }
    };

    // Download horses.js with current stats
    document.getElementById('downloadHorsesBtn').onclick = () => {
      const horseDataArray = horses.map(h => ({
        name: h.name,
        color: h.color,
        baseSpeed: h.stats.baseSpeed,
        stamina: h.stats.stamina,
        sprint: h.stats.sprint,
        variance: h.stats.variance,
        fatigue: h.stats.fatigue,
        kick: h.stats.kick,
        finalBoost: h.stats.finalBoost
      }));

      // Format as single lines
      const horseLines = horseDataArray.map(h => 
        `  { name: "${h.name}", color: "${h.color}", baseSpeed: ${h.baseSpeed}, stamina: ${h.stamina}, sprint: ${h.sprint}, variance: ${h.variance}, fatigue: ${h.fatigue}, kick: ${h.kick}, finalBoost: ${h.finalBoost} }`
      ).join(',\n');

      const jsContent = `// Horse Racing Data
// Edit these values to customize your horses

window.HORSE_DATA = [
${horseLines}
];
`;

      const blob = new Blob([jsContent], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'horses.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('horses.js downloaded! Replace your old horses.js file with this new one.');
    };

    // Copy horses.js to clipboard
    document.getElementById('copyHorsesBtn').onclick = () => {
      const horseDataArray = horses.map(h => ({
        name: h.name,
        color: h.color,
        baseSpeed: h.stats.baseSpeed,
        stamina: h.stats.stamina,
        sprint: h.stats.sprint,
        variance: h.stats.variance,
        fatigue: h.stats.fatigue,
        kick: h.stats.kick,
        finalBoost: h.stats.finalBoost
      }));

      // Format as single lines
      const horseLines = horseDataArray.map(h => 
        `  { name: "${h.name}", color: "${h.color}", baseSpeed: ${h.baseSpeed}, stamina: ${h.stamina}, sprint: ${h.sprint}, variance: ${h.variance}, fatigue: ${h.fatigue}, kick: ${h.kick}, finalBoost: ${h.finalBoost} }`
      ).join(',\n');

      const jsContent = `// Horse Racing Data
// Edit these values to customize your horses

window.HORSE_DATA = [
${horseLines}
];
`;

      navigator.clipboard.writeText(jsContent).then(() => {
        alert('‚úÖ horses.js code copied to clipboard!\n\n1. Open a text editor (Notepad, etc.)\n2. Paste (Ctrl+V)\n3. Save as "horses.js"\n4. Put it in the same folder as your HTML file');
      }).catch(err => {
        // Fallback: show in a text area for manual copy
        const textarea = document.createElement('textarea');
        textarea.value = jsContent;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '50%';
        textarea.style.transform = 'translate(-50%, -50%)';
        textarea.style.width = '80%';
        textarea.style.height = '80%';
        textarea.style.zIndex = '10000';
        textarea.style.background = 'white';
        textarea.style.color = 'black';
        textarea.style.padding = '20px';
        document.body.appendChild(textarea);
        textarea.select();
        alert('Copy this code manually (Ctrl+A then Ctrl+C), then close this box');
        setTimeout(() => document.body.removeChild(textarea), 30000);
      });
    };

    // Download racehistory.js
    document.getElementById('downloadRaceHistoryBtn').onclick = () => {
      const jsContent = `// Race History Data
// This file stores all completed race results

window.RACE_HISTORY_DATA = {
  raceNumber: ${raceNumber},
  races: ${JSON.stringify(raceHistory, null, 2)}
};
`;

      const blob = new Blob([jsContent], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'racehistory.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('racehistory.js downloaded! Add this line to your HTML before the main script tag.');
    };

    // Copy racehistory.js to clipboard
    document.getElementById('copyRaceHistoryBtn').onclick = () => {
      const jsContent = `// Race History Data
// This file stores all completed race results

window.RACE_HISTORY_DATA = {
  raceNumber: ${raceNumber},
  races: ${JSON.stringify(raceHistory, null, 2)}
};
`;

      navigator.clipboard.writeText(jsContent).then(() => {
        alert('racehistory.js code copied to clipboard!');
      }).catch(err => {
        const textarea = document.createElement('textarea');
        textarea.value = jsContent;
        textarea.style.position = 'fixed';
        textarea.style.top = '50%';
        textarea.style.left = '50%';
        textarea.style.transform = 'translate(-50%, -50%)';
        textarea.style.width = '80%';
        textarea.style.height = '80%';
        textarea.style.zIndex = '10000';
        textarea.style.background = 'white';
        textarea.style.color = 'black';
        textarea.style.padding = '20px';
        document.body.appendChild(textarea);
        textarea.select();
        alert('Copy this code manually then close this box');
        setTimeout(() => document.body.removeChild(textarea), 30000);
      });
    };

    // Toggle UI visibility
    const toggleUIBtn = document.getElementById('toggleUI');
    const uiPanel = document.getElementById('ui');
    toggleUIBtn.onclick = () => {
      uiPanel.classList.toggle('hidden');
      toggleUIBtn.textContent = uiPanel.classList.contains('hidden') ? 'Show Settings ‚öôÔ∏è' : 'Hide Settings ‚öôÔ∏è';
    };

    // Kick off
    loadRaceHistory(); // Load saved history
    refreshButtonsIfLoaded();
    refreshLeaderboard();
    updateRaceHistory();
    requestAnimationFrame(loop);
  </script>
</body>
</html>