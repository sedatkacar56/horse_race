<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Horse Racing (Sprite Sheet)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:linear-gradient(#87CEEB,#98D98E);overflow:hidden}
    #gameCanvas{display:block;margin:20px auto;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #ui{
      position:absolute;top:20px;left:20px;background:rgba(139,69,19,.92);
      color:#fff;padding:14px;border-radius:10px;min-width:320px;max-width:380px;
      max-height:80vh;overflow-y:auto;z-index:100
    }
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{min-width:64px;font-size:13px}
    .row input[type="text"], .row input[type="number"]{
      flex:1;border:none;border-radius:6px;padding:6px 8px;outline:none;font-size:13px
    }
    .row input[type="file"]{flex:1}
    .tiny{font-size:12px;opacity:.9}
    .horse-info{background:rgba(0,0,0,.25);padding:6px 8px;border-radius:6px;margin:8px 0}
    #controls{
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      background:rgba(139,69,19,.92);color:#fff;border-radius:10px;padding:14px 16px;
      display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center
    }
    button{
      background:#4CAF50;color:#fff;border:none;border-radius:6px;padding:10px 18px;
      cursor:pointer;transition:.2s;font-size:15px
    }
    button:hover{background:#45a049;transform:scale(1.05)}
    button:disabled{background:#666;transform:none;cursor:not-allowed}
    #winner{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(255,215,0,.96);padding:28px;border-radius:14px;font-weight:700;
      color:#8B4513;display:none;text-align:center;font-size:22px;box-shadow:0 0 40px rgba(255,215,0,.8);
      max-height:70vh;overflow-y:auto;max-width:500px
    }
    #raceResults{
      position:absolute;top:100px;right:20px;background:rgba(139,69,19,.95);
      color:#fff;padding:16px;border-radius:10px;min-width:280px;
      display:none;z-index:100;box-shadow:0 5px 20px rgba(0,0,0,.4)
    }
    .result-item{
      padding:8px;margin:6px 0;background:rgba(0,0,0,.3);border-radius:6px;
      display:flex;align-items:center;gap:10px;font-size:15px
    }
    .result-position{font-weight:bold;font-size:20px;min-width:35px;text-align:center}
    .result-medal{font-size:24px}
    #loadStatus{margin-left:10px;font-size:13px}
    #toggleUI{
      position:absolute;top:20px;right:20px;background:#4CAF50;color:#fff;
      border:none;border-radius:6px;padding:10px 18px;cursor:pointer;
      transition:.2s;font-size:15px;z-index:101
    }
    #toggleUI:hover{background:#45a049}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <button id="toggleUI">Hide Settings ‚öôÔ∏è</button>

  <div id="ui">
    <h3>üèá Sprite Horse Racing</h3>
  
    <div class="row">
      <label>Frames</label>
      <input id="framesInput" type="number" min="2" max="32" />
    </div>
    <div class="row">
      <label>Scale</label>
      <input id="scaleInput" type="number" min="0.2" max="4" step="0.1" />
    </div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">

<h4 style="margin:8px 0">üé® Sprite</h4>
<div class="row">
  <label>Files</label>
  <input id="spriteFiles" type="file" accept="image/*" multiple>
</div>

<div id="spritePreview" class="tiny" style="margin-top:8px;line-height:1.4"></div>


    <div class="tiny">Tip: If the horse looks too small/large, change <b>Scale</b>.</div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">

    <div id="leaderboard"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üìú Race History</h4>
    <div id="raceHistory" style="max-height:200px;overflow-y:auto"></div>
    <button id="clearHistoryBtn" style="margin-top:8px;font-size:12px;padding:6px 12px">Clear History</button>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üèÜ All Horses Complete Stats</h4>
    <div id="completeStats" style="max-height:250px;overflow-y:auto;font-size:12px"></div>
    
    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üíæ Export Settings</h4>
    <button id="downloadRaceHistoryBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#FF9800;margin-bottom:6px">Download racehistory.js</button>
  </div>

  <div id="controls">
    <button id="startBtn" disabled>Start Race</button>
    <button id="resetBtn" disabled>Reset Race</button>
    <button id="pauseBtn" disabled>Pause</button>
    <span id="loadStatus" class="tiny">Loading sprites‚Ä¶</span>
  </div>

  <div id="winner"></div>
  <div id="raceResults"></div>

  <!-- Your horse stats -->
  <script src="horses.js"></script>
	
  <script src="race_params.js"></script>

<script src="strategies/strategies.js"></script>  <!-- ADD THIS -->


  <script>

    /* ---------- SPRITE SETTINGS ---------- */
    const SPRITE_SRC_DEFAULT = "default.jpg";
    const SPRITE_FRAMES_DEFAULT = 6;
    const SPRITE_SCALE_DEFAULT  = 1.0;
    /* ------------------------------------ */

// Canvas & world
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Use params from race_params.js if available, otherwise defaults
const PARAMS = window.RACE_PARAMS || {cw:1200, ch:600, ww:5000, lg:10, lo:100, fl:4500};

const VIEW_W = PARAMS.cw;
const VIEW_H = PARAMS.ch;
const worldWidth = PARAMS.ww;
const laneGap = PARAMS.lg;
const laneOffset = PARAMS.lo;
const finishLine = PARAMS.fl;

console.log("üèá Using parameters:", PARAMS);

// üîπ High-DPI (Retina / HD) rendering setup
const DPR = Math.max(3, window.devicePixelRatio || 1);
canvas.width  = VIEW_W * DPR;
canvas.height = VIEW_H * DPR;
canvas.style.width  = VIEW_W + 'px';
canvas.style.height = VIEW_H + 'px';
ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
ctx.imageSmoothingEnabled = false;        // set false for pixel-art
ctx.imageSmoothingQuality = 'high';

// Apply track colors from horses.js
if (window.TRACK_STYLE) {
  const top = window.TRACK_STYLE.backgroundTop || '#7CB342';
  const bottom = window.TRACK_STYLE.backgroundBottom || '#558B2F';
  const border = window.TRACK_STYLE.border || '#8B4513';
  canvas.style.background = `linear-gradient(${top}, ${bottom})`;
  canvas.style.border = `8px solid ${border}`;
}






// === Dynamic furlong calculation ===
const START_X = 50; // same as your horse starting X
const PPF = window.RACE_PARAMS?.pixelsPerFurlong ?? 500; // pixels per furlong

// If user didn't explicitly define "furlongs" in race_params.js,
// estimate it based on finishLine distance.
const FURLONGS_TOTAL = (window.RACE_PARAMS?.furlongs)
  ?? Math.round((finishLine - START_X) / PPF);

console.log(`üìè Track length: ${FURLONGS_TOTAL} furlongs (${finishLine - START_X}px)`);

// This ensures your drawTrack() and progress calculations both adapt dynamically.

// Display parameters on screen
const paramInfo = document.createElement('div');
paramInfo.style.cssText =
  'position:fixed;top:10px;left:50%;transform:translateX(-50%);' +
  'background:rgba(0,0,0,0.8);color:lime;padding:10px;border-radius:8px;' +
  'font-family:monospace;font-size:12px;z-index:9999;';

paramInfo.innerHTML = `
‚öôÔ∏è Race Parameters:<br>
World: ${worldWidth}px | Finish: ${finishLine}px<br>
Canvas: ${VIEW_W}x${VIEW_H} | Lane Gap: ${laneGap}<br>
üèÅ Estimated Distance: <b>${FURLONGS_TOTAL} furlongs</b>
`;

document.body.appendChild(paramInfo);
setTimeout(() => paramInfo.remove(), 5000);


    let raceActive = false;
    let raceFinished = false;
    let cameraX = 0;
    let finishOrder = [];
    let raceHistory = []; // Store all race results
    let raceNumber = 0;

    // Load race history from racehistory.js if available
    if (window.RACE_HISTORY_DATA) {
      raceHistory = window.RACE_HISTORY_DATA.races || [];
      raceNumber = window.RACE_HISTORY_DATA.raceNumber || 0;
      console.log('Loaded race history from racehistory.js:', raceHistory.length, 'races');
    }

    // Load race history from storage on startup
    async function loadRaceHistory() {
      // Skip loading from storage if racehistory.js was already loaded
      if (window.RACE_HISTORY_DATA) {
        updateRaceHistory();
        refreshLeaderboard();
        return;
      }
      
      try {
        // Try Claude.ai storage first
        if (window.storage) {
          const result = await window.storage.get('horse-race-history');
          if (result && result.value) {
            const data = JSON.parse(result.value);
            raceHistory = data.races || [];
            raceNumber = data.raceNumber || 0;
            console.log('Loaded race history from Claude storage:', raceHistory.length, 'races');
            updateRaceHistory();
            refreshLeaderboard();
            return;
          }
        }
      } catch (error) {
        console.log('Claude storage not available, trying localStorage');
      }
      
      // Fallback to localStorage
      try {
        const stored = localStorage.getItem('horse-race-history');
        if (stored) {
          const data = JSON.parse(stored);
          raceHistory = data.races || [];
          raceNumber = data.raceNumber || 0;
          console.log('Loaded race history from localStorage:', raceHistory.length, 'races');
          updateRaceHistory();
          refreshLeaderboard();
        }
      } catch (error) {
        console.log('No previous race history found');
      }
    }

    // Save race history to storage
    async function saveRaceHistory() {
      const data = JSON.stringify({
        races: raceHistory,
        raceNumber: raceNumber
      });
      
      // Try Claude.ai storage
      try {
        if (window.storage) {
          await window.storage.set('horse-race-history', data);
          console.log('Race history saved to Claude storage');
        }
      } catch (error) {
        console.log('Claude storage not available');
      }
      
      // Always save to localStorage as backup
      try {
        localStorage.setItem('horse-race-history', data);
        console.log('Race history saved to localStorage');
      } catch (error) {
        console.error('Failed to save race history:', error);
      }
    }

    // Shared sprite config
    const spriteConfig = {
      frames: SPRITE_FRAMES_DEFAULT,
      scale:  SPRITE_SCALE_DEFAULT,
      fps:    14
    };

    // Preload the default sprite
    const horseSprite = new Image();
    horseSprite.src = SPRITE_SRC_DEFAULT;

    // Fallback colors
    const palette = [
      "#8B0000","#FFD700","#4169E1","#FF4500","#2F4F4F","#32CD32","#9932CC","#FF69B4",
      "#00CED1","#D2691E","#E6E6FA","#DC143C","#708090","#FF6347","#9ACD32","#8A2BE2",
      "#00FA9A","#FFDAB9","#FF8C00","#1E90FF","#A0522D","#ADFF2F","#00BFFF","#20B2AA"
    ];
    
if (!Array.isArray(window.HORSE_DATA) || HORSE_DATA.length === 0) {
  loadStatus.textContent = "HORSE_DATA missing. Check horses.js is loaded and defines HORSE_DATA.";
  console.error("HORSE_DATA is missing or empty. Make sure horses.js is loaded before this script.");
}


    const horses = HORSE_DATA.map((h, i) => ({
      name:  h.name,
      color: h.color || palette[i % palette.length],
      lane:  i + 1,
      x: 50,
      y: laneOffset + i * laneGap,
      speed: 0,
      step: 0,
      animTime: 0,
      sprite: null,
      finished: false,
      finishTime: null,
      stats: {
        baseSpeed:  Number(h.baseSpeed),
        stamina:    Number(h.stamina),
        sprint:     Number(h.sprint),
        variance:   Number(h.variance),
        fatigue:    Number(h.fatigue),
        kick:       Number(h.kick),
        finalBoost: Number(h.finalBoost)
      }
    }));




// UI refs
const spriteFileInput = document.getElementById('spriteFiles');
const spritePreviewEl  = document.getElementById('spritePreview');

// Change handler (uses your single-sprite applySpriteFiles)
spriteFileInput?.addEventListener('change', (e) => {
  const files = e.target.files;
  if (files && files.length) applySpriteFiles(files); // <-- call existing function
});



// Optional: drag & drop (first image only)
document.addEventListener('dragover', (e) => e.preventDefault());
document.addEventListener('drop', (e) => {
  e.preventDefault();
  const file = Array.from(e.dataTransfer?.files || []).find(f => f.type.startsWith('image/'));
  if (file) applySpriteFiles([file]); // wrap single file as a list
});

// One file -> all horses. Keeps default sprite if nothing chosen.
function applySpriteFiles(files) {
  const file = (files && files[0]) || null;
  if (!file || !file.type?.startsWith('image/')) return;

  const url = URL.createObjectURL(file);
  const img = new Image();

  img.onload = () => {
    // assign the SAME image object to every horse
    horses.forEach(h => { h.sprite = { img }; });

    // UI updates
    refreshButtonsIfLoaded?.();
    refreshLeaderboard?.();

    // Preview (single entry)
    const purl = URL.createObjectURL(file);
    spritePreviewEl.innerHTML = `
      <div style="margin:4px 0;padding:6px;background:rgba(0,0,0,0.18);border-radius:6px">
        <div><b>All horses</b> <span style="opacity:.7">(same file)</span></div>
        <div style="display:flex;align-items:center;gap:8px;margin-top:4px">
          <img src="${purl}" style="height:28px;border-radius:4px;box-shadow:0 0 0 1px rgba(255,255,255,.2)">
          <span class="tiny" style="opacity:.8">${file.name}</span>
        </div>
      </div>`;
    setTimeout(() => URL.revokeObjectURL(purl), 30000); // let preview live a bit

    URL.revokeObjectURL(url);
  };

  img.src = url;
}







    // Frames/Scale UI
    const framesInput = document.getElementById('framesInput');
    const scaleInput  = document.getElementById('scaleInput');
    framesInput.value = SPRITE_FRAMES_DEFAULT;
    scaleInput.value  = SPRITE_SCALE_DEFAULT;
    framesInput.oninput = () => { spriteConfig.frames = Math.max(2, Math.min(32, +framesInput.value||SPRITE_FRAMES_DEFAULT)); };
    scaleInput.oninput  = () => { spriteConfig.scale  = Math.max(0.2, Math.min(4, +scaleInput.value||SPRITE_SCALE_DEFAULT)); };

    // Track drawing
    // Track drawing with realistic racing elements
    
function drawTrack() {
  // Use colors from TRACK_STYLE or fallback to defaults
  const topColor = window.TRACK_STYLE?.backgroundTop || '#D2B48C';
  const bottomColor = window.TRACK_STYLE?.backgroundBottom || '#C19A6B';
  
  // Draw gradient background
  const gradient = ctx.createLinearGradient(0, 0, 0, VIEW_H);
  gradient.addColorStop(0, topColor);
  gradient.addColorStop(1, bottomColor);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, worldWidth, VIEW_H);

  // === INNER RAIL (top border) ===
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, laneOffset - laneGap/2 - 8, worldWidth, 8);
  // Rail posts
  for (let x = 0; x < worldWidth; x += 80) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(x, laneOffset - laneGap/2 - 12, 6, 16);
  }

  // === OUTER RAIL (bottom border) ===
  const outerRailY = laneOffset - laneGap/2 + horses.length * laneGap;
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, outerRailY, worldWidth, 8);
  // Rail posts
  for (let x = 0; x < worldWidth; x += 80) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(x, outerRailY - 4, 6, 16);
  }

  // === STARTING GATE ===
  const gateX = 30;
  const gateWidth = 15;
  
  // Gate frame
  ctx.fillStyle = '#4A4A4A';
  ctx.fillRect(gateX - 5, laneOffset - laneGap/2 - 10, 5, outerRailY - (laneOffset - laneGap/2) + 20);
  ctx.fillRect(gateX + gateWidth, laneOffset - laneGap/2 - 10, 5, outerRailY - (laneOffset - laneGap/2) + 20);
  
  // Individual stall gates
  for (let i = 0; i < horses.length; i++) {
    const stallY = laneOffset - laneGap/2 + i * laneGap;
    
    // Stall divider
    ctx.fillStyle = '#666';
    ctx.fillRect(gateX - 5, stallY + laneGap - 2, gateWidth + 10, 3);
    
    // Gate door (closed before race, open during)
    if (!raceActive && !raceFinished) {
      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      ctx.fillRect(gateX, stallY, gateWidth, laneGap - 3);
      
      // Gate bars
      for (let b = 0; b < 4; b++) {
        ctx.fillStyle = '#888';
        ctx.fillRect(gateX + b * 4, stallY, 2, laneGap - 3);
      }
    }
    
    // Lane number on gate
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(i + 1, gateX + gateWidth/2, stallY + laneGap/2 + 6);
  }

  // === LANE DIVIDERS (white dashed lines) ===
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 5]);
  for (let i = 1; i < horses.length; i++) {
    ctx.beginPath();
    ctx.moveTo(0, laneOffset - laneGap/2 + i * laneGap);
    ctx.lineTo(worldWidth, laneOffset - laneGap/2 + i * laneGap);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // === FURLONG MARKERS ===
// Use global FURLONGS_TOTAL defined above
  for (let f = 1; f <= FURLONGS_TOTAL; f++) {
    const x = 50 + (finishLine - 50) * (f / FURLONGS_TOTAL);
    
    ctx.save();
    // Marker pole
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.moveTo(x, laneOffset - laneGap / 2);
    ctx.lineTo(x, outerRailY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Furlong pole top
    ctx.fillStyle = '#fff';
    ctx.fillRect(x - 3, laneOffset - laneGap / 2 - 20, 6, 16);
    
    // Furlong number
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#0066cc';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
    ctx.fillText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
    ctx.restore();
  }

  // === FINISH LINE ===
  const finishWidth = 35;
  
  // Red finish post
  ctx.fillStyle = '#CC0000';
  ctx.fillRect(finishLine - 3, 0, 6, VIEW_H);
  
  // Checkered pattern
  const checkerSize = 20;
  for (let y = 0; y < VIEW_H; y += checkerSize) {
    for (let x = 0; x < finishWidth; x += checkerSize) {
      const isBlack = ((x / checkerSize) + (y / checkerSize)) % 2 === 0;
      ctx.fillStyle = isBlack ? '#000' : '#fff';
      ctx.fillRect(finishLine + 3, y, checkerSize, checkerSize);
      ctx.fillRect(finishLine + 3 + checkerSize, y, checkerSize, checkerSize);
    }
  }
  
  // Finish line banner
  ctx.fillStyle = 'rgba(204, 0, 0, 0.9)';
  ctx.fillRect(finishLine - 20, 10, finishWidth + 40, 35);
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 24px Arial';
  ctx.textAlign = 'center';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4;
  ctx.strokeText('FINISH', finishLine + finishWidth/2 - 10, 32);
  ctx.fillText('FINISH', finishLine + finishWidth/2 - 10, 32);

  // === DISTANCE MARKERS ON TRACK ===
  // Starting line
  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.fillRect(48, laneOffset - laneGap/2, 4, outerRailY - (laneOffset - laneGap/2));
}
  






// Sprite drawing with proper color tinting (HD-safe)
function drawHorseSprite(horse, dt) {
  const { frames, scale, fps } = spriteConfig;
  const hasSprite = horse.sprite && horse.sprite.img && horse.sprite.img.complete;

  function drawName(yOffset){
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 4;
    ctx.strokeText(horse.name, 0, yOffset);
    ctx.fillStyle = '#fff';
    ctx.fillText(horse.name, 0, yOffset);
  }

  // ---------- DEFAULT SPRITE BRANCH ----------
  if (!hasSprite && horseSprite.complete) {
    ctx.save();
    ctx.translate(horse.x, horse.y);

    const animFps = fps + horse.speed * 0.6;
    horse.animTime = (horse.animTime || 0) + animFps * dt;

    const frameWidth  = horseSprite.width / SPRITE_FRAMES_DEFAULT;
    const frameHeight = horseSprite.height;
    const frame       = Math.floor(horse.animTime) % SPRITE_FRAMES_DEFAULT;

    const drawWidth  = frameWidth  * SPRITE_SCALE_DEFAULT;
    const drawHeight = frameHeight * SPRITE_SCALE_DEFAULT;

    // temp canvas at native frame size (no scaling here)
    const tcan = document.createElement('canvas');
    const tctx = tcan.getContext('2d');
    tcan.width  = frameWidth;
    tcan.height = frameHeight;

    // draw native frame
    tctx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, frameWidth, frameHeight
    );

    // tint (light colors use 'screen')
    const light1 = (horse.color || '').trim().toUpperCase();
    tctx.globalCompositeOperation =
      ['#FFFFFF','#D3D3D3','#F5DEB3','#C0C0C0','#A9A9A9'].includes(light1) ? 'screen' : 'multiply';
    tctx.fillStyle = horse.color;
    tctx.fillRect(0, 0, frameWidth, frameHeight);

    // restore alpha
    tctx.globalCompositeOperation = 'destination-in';
    tctx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, frameWidth, frameHeight
    );
    tctx.globalCompositeOperation = 'source-over';

    // scale ONCE when drawing to the main canvas
    ctx.drawImage(tcan, -drawWidth / 2, -drawHeight / 2 - 45, drawWidth, drawHeight);

    drawName(-drawHeight * 0.6);
    ctx.restore();
    return;
  }

  // ---------- FALLBACK CIRCLE ----------
  if (!hasSprite) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    ctx.fillStyle = horse.color;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(horse.lane, 0, 0);
    drawName(-30);
    ctx.restore();
    return;
  }

  // ---------- CUSTOM SPRITE BRANCH ----------
  const img = horse.sprite.img;
  const frameW = Math.floor(img.width / frames);
  const frameH = img.height;

  const animFps = fps + horse.speed * 0.6;
  horse.animTime = (horse.animTime || 0) + animFps * dt;
  const frameIndex = Math.floor(horse.animTime) % frames;

  const drawW = frameW * scale;
  const drawH = frameH * scale;

  ctx.save();
  ctx.translate(horse.x, horse.y);

  // temp canvas at native frame size (no scaling here)
  const tcan = document.createElement('canvas');
  const tctx = tcan.getContext('2d');
  tcan.width  = frameW;
  tcan.height = frameH;

  // draw native frame
  tctx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, frameW, frameH
  );

  // tint (light colors use 'screen')
  const light2 = (horse.color || '').trim().toUpperCase();
  tctx.globalCompositeOperation =
    ['#FFFFFF','#D3D3D3','#F5DEB3','#C0C0C0','#A9A9A9'].includes(light2) ? 'screen' : 'multiply';
  tctx.fillStyle = horse.color;
  tctx.fillRect(0, 0, frameW, frameH);

  // restore alpha
  tctx.globalCompositeOperation = 'destination-in';
  tctx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, frameW, frameH
  );
  tctx.globalCompositeOperation = 'source-over';

  // scale ONCE when drawing to the main canvas
  ctx.drawImage(tcan, -drawW * 0.5, -drawH * 0.5, drawW, drawH);

  drawName(-drawH * 0.6);
  ctx.restore();
}











    // Leaderboard & results
    const leaderboard = document.getElementById('leaderboard');
    const raceResults = document.getElementById('raceResults');
    const raceHistoryEl = document.getElementById('raceHistory');

  function refreshLeaderboard() {
  const sorted = [...horses].sort((a,b) => b.x - a.x);
  let html = '<h4 style="margin:8px 0">üèá Current Standings</h4>';
  sorted.forEach((h,i) => {
    const pct = Math.max(0, Math.round((h.x / finishLine) * 100));
    
    // Build race code
    let raceCode = '';
    raceHistory.forEach(race => {
      const result = race.results.find(r => r.name === h.name);
      if (result) {
        raceCode += result.position >= 10 ? '0' : result.position;
      }
    });
    const displayCode = raceCode || '----';
    
    // ADD STRATEGY BADGE
    const strategyBadge = h.strategy 
      ? `<span style="background:${getStrategyColor(h.strategy)};color:white;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px">${h.strategy}</span>`
      : '';
    
    // FIXED: Show everything in ONE div (not two!)
    html += `<div class="horse-info">
      ${i+1}. <b>${h.name}</b> ${strategyBadge} ‚Äî Lane ${h.lane} ‚Äî <span style="color:${h.color}">‚óè</span> ${pct}%
      <div class="tiny">Race history: ${displayCode}</div>
    </div>`;
  });
  leaderboard.innerHTML = html;
}

// ADD THIS HELPER FUNCTION
function getStrategyColor(strategy) {
  switch(strategy) {
    case 'FRONT_RUNNER': return '#ff4444';
    case 'PRESSER': return '#ff9800';
    case 'STALKER': return '#2196F3';
    case 'CLOSER': return '#9c27b0';
    default: return '#666';
  }
}


function showStrategySummary(horses) {
  const counts = { FRONT_RUNNER: 0, PRESSER: 0, STALKER: 0, CLOSER: 0 };
  horses.forEach(h => counts[h.strategy] = (counts[h.strategy] || 0) + 1);

  const getColor = getStrategyColor; // reuse your existing color function

  // Build small summary panel
  const summaryHTML = `
    <div id="strategySummary" style="
      background:rgba(0,0,0,0.2);
      padding:10px;
      margin:8px 0;
      border-radius:6px;
      font-size:13px;">
      <div style="font-weight:bold;margin-bottom:4px;">üèá Strategy Mix</div>
      ${Object.entries(counts).map(([name,count]) =>
        `<div style="margin:2px 0;">
          <span style="display:inline-block;width:12px;height:12px;background:${getColor(name)};border-radius:3px;margin-right:6px;"></span>
          ${name.replace('_',' ')}: <b>${count}</b>
        </div>`).join('')}
    </div>
  `;

  const leaderboard = document.getElementById('leaderboard');
  if (leaderboard) {
    // Remove previous summary if it exists
    const existing = document.getElementById('strategySummary');
    if (existing) existing.remove();

    // Insert before leaderboard section
    leaderboard.insertAdjacentHTML('beforebegin', summaryHTML);
  }
}



    function updateRaceHistory() {
      if (raceHistory.length === 0) {
        raceHistoryEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        updateCompleteStats();
        return;
      }
      
      let html = '';
      raceHistory.slice().reverse().forEach((race, idx) => {
        const actualRaceNum = raceHistory.length - idx;
        html += `<div style="background:rgba(0,0,0,0.2);padding:8px;margin:6px 0;border-radius:6px">
          <div style="font-weight:bold;margin-bottom:4px">Race #${actualRaceNum}</div>
          <div style="font-size:12px">`;
        
        race.results.forEach(r => {
          const medal = r.position === 1 ? 'ü•á' : r.position === 2 ? 'ü•à' : r.position === 3 ? 'ü•â' : '';
          html += `<div style="padding:2px 0">
            ${medal} ${r.position}. <span style="color:${r.color}">‚óè</span> ${r.name} (L${r.lane})
          </div>`;
        });
        
        html += `</div></div>`;
      });
      
      raceHistoryEl.innerHTML = html;
      updateCompleteStats();
    }

function updateCompleteStats() {
  const completeStatsEl = document.getElementById('completeStats');
  if (!Array.isArray(window.HORSE_DATA) || HORSE_DATA.length === 0) {
    completeStatsEl.innerHTML = '<div class="tiny" style="opacity:0.7">No horses found</div>';
    return;
  }

  let html = '<div style="background:rgba(0,0,0,0.2);padding:8px;border-radius:6px">';
  HORSE_DATA.forEach(h => {
    const pos = h.position ?? '-';
    html += `
      <div style="padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1)">
        <span style="color:${h.color};font-size:16px">‚óè</span> 
        <b>${h.name}</b> ‚Äî ${pos}
      </div>`;
  });
  html += '</div>';
  completeStatsEl.innerHTML = html;
}


    function updateRaceResults() {
      if (!raceActive && finishOrder.length === 0) {
        raceResults.style.display = 'none';
        return;
      }
      raceResults.style.display = 'block';
      let html = '<h3 style="margin:0 0 10px 0; font-size:18px;">üìä Race Results</h3>';

      if (finishOrder.length > 0) {
        finishOrder.forEach((h, i) => {
          const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
          html += `<div class="result-item">
            <span class="result-position">${i+1}${getOrdinalSuffix(i+1)}</span>
            ${medal ? `<span class="result-medal">${medal}</span>` : ''}
            <span style="color:${h.color};font-size:20px">‚óè</span>
            <span style="flex:1"><b>${h.name}</b><br/><small>Lane ${h.lane}</small></span>
          </div>`;
        });
      }

      const stillRacing = horses.filter(h => !h.finished);
      if (stillRacing.length > 0) {
        html += '<div style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.3)">';
        html += '<div style="font-size:13px;opacity:0.8;margin-bottom:6px">Still Racing:</div>';
        stillRacing.forEach(h => {
          const pct = Math.max(0, Math.min(100, Math.round((h.x / finishLine) * 100)));
          html += `<div style="padding:4px;margin:3px 0;font-size:13px">
            <span style="color:${h.color}">‚óè</span> ${h.name} - ${pct}%
          </div>`;
        });
        html += '</div>';
      }
      raceResults.innerHTML = html;
    }

    function getOrdinalSuffix(num) {
      const j = num % 10, k = num % 100;
      if (j === 1 && k !== 11) return 'st';
      if (j === 2 && k !== 12) return 'nd';
      if (j === 3 && k !== 13) return 'rd';
      return 'th';
    }

   
    // Race control
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const loadStatus = document.getElementById('loadStatus');
    const pauseBtn = document.getElementById('pauseBtn')
    let isPaused = false

    function togglePause() {
  if (!raceActive && !raceFinished) return; // nothing to pause
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
}

pauseBtn.onclick = togglePause;

// Optional shortcuts: Space or "P" to pause/resume
window.addEventListener('keydown', (e) => {
  const k = e.key.toLowerCase();
  if (k === 'p' || k === ' ') {
    e.preventDefault();
    togglePause();
  }
});



    function startRace() {
      if (raceActive) return;
      raceActive = true;
      raceFinished = false;
      isPaused = false;
      pauseBtn.textContent = 'Pause';
      pauseBtn.disabled = false;
      finishOrder = [];
      horses.forEach(h => {
        h.finished = false;
        h.finishTime = null;
        h._lateKickUsed = false;
        h._finalBoostUsed = false;
        h._kickTimer = 0;
        h._kickCooldown = 0;
      });

      
      // ‚≠ê Dynamic strategy caller
const strategyFuncName = window.RACE_PARAMS?.strategy || 'assignRacingStrategies_sedat';
const strategyFunc = window[strategyFuncName];

if (typeof strategyFunc === 'function') {
  strategyFunc(horses);
  console.log(`‚úÖ Using strategy: ${strategyFuncName}`);
} else {
  console.error(`‚ùå Strategy function "${strategyFuncName}" not found!`);
  // Fallback to default
  if (typeof window.assignRacingStrategies_sedat === 'function') {
    window.assignRacingStrategies_sedat(horses);
    console.log('‚ö†Ô∏è Falling back to assignRacingStrategies_sedat');
  }
}





      startBtn.disabled = true;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'block';
      lastTs = performance.now();
    }

    function resetRace() {
      raceActive = false;
      raceFinished = false;
      isPaused = false;
      pauseBtn.textContent = 'Pause';
      pauseBtn.disabled = false;
      cameraX = 0;
      finishOrder = [];
      horses.forEach(h=>{
        h.x=50; h.speed=0; h.step=0; h.animTime=0;
        h.y = laneOffset + (h.lane-1)*laneGap;
        h._kickTimer = 0;
        h._kickCooldown = 0;
        h._finalBoostUsed = false;
        h._lateKickUsed = false;
        h.finished = false;
        h.finishTime = null;
      });
      startBtn.disabled = false;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'none';
      refreshLeaderboard();
    }





    function shuffleLanes() {
      const ids = horses.map((_, i) => i + 1).sort(() => Math.random() - 0.5);
      horses.forEach((h,i) => {
        h.lane = ids[i];
        h.y = laneOffset + (h.lane-1)*laneGap;
      });
      refreshLeaderboard();
    }

    function showResults() {
      const el = document.getElementById('winner');
      let html = `<div style="font-size:28px; margin-bottom:16px;">üèÜ RACE COMPLETE üèÜ</div>`;
      html += '<div style="text-align:left;">';
      finishOrder.forEach((h, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
        html += `<div style="margin:10px 0; font-size:${22-i*1.5}px; padding:8px; background:rgba(139,69,19,0.3); border-radius:6px;">
          ${medal} <b>${i+1}${getOrdinalSuffix(i+1)}</b> - <span style="color:${h.color}">‚óè</span> ${h.name} <small style="opacity:0.8">(Lane ${h.lane})</small>
        </div>`;
      });
      html += '</div>';
      el.innerHTML = html;
      el.style.display = 'block';
      resetBtn.disabled = false;
      startBtn.disabled = true;
      
      // Save race to history
      raceNumber++;
      raceHistory.push({
        raceNum: raceNumber,
        results: finishOrder.map((h, i) => ({
          position: i + 1,
          name: h.name,
          lane: h.lane,
          color: h.color
        }))
      });
      updateRaceHistory();
      refreshLeaderboard(); // Update to show new "last race" positions
      saveRaceHistory(); // Save to storage
    }

    function refreshButtonsIfLoaded() {
      const allReady = horseSprite.complete || horses.some(h => h.sprite?.img?.complete);
      startBtn.disabled   = !allReady;
      resetBtn.disabled   = true;
      loadStatus.textContent = allReady ? "Sprites loaded. Ready to race!" : "Loading sprites‚Ä¶";
    }
    horseSprite.onload = refreshButtonsIfLoaded;

    // Game loop with camera tracking
    let lastTs = performance.now();
    function loop(ts) {
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;

        // Freeze camera when paused
 // Update camera only when active/finished and not paused
  if ((raceActive || raceFinished) && !isPaused) {
    const leader = Math.max(...horses.map(h => h.x));
    const targetCameraX = Math.max(0, Math.min(worldWidth - VIEW_W, leader - VIEW_W * 0.3));
    cameraX += (targetCameraX - cameraX) * 0.1;
  }

  ctx.save();
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  ctx.translate(-cameraX, 0);

      drawTrack();
      // Pass 0 dt to freeze sprite animation while paused
      const dtUsed = isPaused ? 0 : dt;
      horses.slice().sort((a,b)=>a.y-b.y).forEach(h => drawHorseSprite(h, dtUsed));

      ctx.restore();
      
if (!isPaused) {

  // Get physics function name
  const updateFuncName = window.RACE_PARAMS?.update;
  const updateFunc = window[updateFuncName];
  
  if (typeof updateFunc === 'function') {
    updateFunc(dt);
  } else {
    console.error(`‚ùå Physics function "${updateFuncName}" not found!`);
  }


  } else {
    // keep results/leaderboard visible while paused
    updateRaceResults();
  }

      requestAnimationFrame(loop);
    }

    // Buttons
    startBtn.onclick = startRace;
    resetBtn.onclick = resetRace;
        
    document.getElementById('clearHistoryBtn').onclick = () => {
      if (confirm('Clear all race history?')) {
        raceHistory = [];
        raceNumber = 0;
        updateRaceHistory();
        refreshLeaderboard();
        saveRaceHistory(); // Save cleared state
      }
    };


// Dynamic Strategy Assignment System
// Assigns strategies based on how each horse compares to the AVERAGE of the race field




    // Download racehistory.js
    document.getElementById('downloadRaceHistoryBtn').onclick = () => {
      const jsContent = `// Race History Data
// This file stores all completed race results

window.RACE_HISTORY_DATA = {
  raceNumber: ${raceNumber},
  races: ${JSON.stringify(raceHistory, null, 2)}
};
`;

      const blob = new Blob([jsContent], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'racehistory.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('racehistory.js downloaded! Add this line to your HTML before the main script tag.');
    };

 

    // Toggle UI visibility
    const toggleUIBtn = document.getElementById('toggleUI');
    const uiPanel = document.getElementById('ui');
    uiPanel.classList.add('hidden'); // start hidden
    
    toggleUIBtn.onclick = () => {
      uiPanel.classList.toggle('hidden');
      toggleUIBtn.textContent = uiPanel.classList.contains('hidden') ? 'Show Settings ‚öôÔ∏è' : 'Hide Settings ‚öôÔ∏è';
    };

    // Kick off
    loadRaceHistory(); // Load saved history
    refreshButtonsIfLoaded();
    refreshLeaderboard();
    updateRaceHistory();
    requestAnimationFrame(loop);
  </script>
</body>
</html>