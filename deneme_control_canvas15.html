<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Horse Racing (Sprite Sheet)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:linear-gradient(#87CEEB,#98D98E);overflow:hidden}
    #gameCanvas{display:block;margin:20px auto;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #ui{
      position:absolute;top:20px;left:20px;background:rgba(139,69,19,.92);
      color:#fff;padding:14px;border-radius:10px;min-width:320px;max-width:380px;
      max-height:80vh;overflow-y:auto;z-index:100
    }
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{min-width:64px;font-size:13px}
    .row input[type="text"], .row input[type="number"]{
      flex:1;border:none;border-radius:6px;padding:6px 8px;outline:none;font-size:13px
    }
    .row input[type="file"]{flex:1}
    .tiny{font-size:12px;opacity:.9}
    .horse-info{background:rgba(0,0,0,.25);padding:6px 8px;border-radius:6px;margin:8px 0}
    #controls{
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      background:rgba(139,69,19,.92);color:#fff;border-radius:10px;padding:14px 16px;
      display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center
    }
    button{
      background:#4CAF50;color:#fff;border:none;border-radius:6px;padding:10px 18px;
      cursor:pointer;transition:.2s;font-size:15px
    }
    button:hover{background:#45a049;transform:scale(1.05)}
    button:disabled{background:#666;transform:none;cursor:not-allowed}
    #winner{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(255,215,0,.96);padding:28px;border-radius:14px;font-weight:700;
      color:#8B4513;display:none;text-align:center;font-size:22px;box-shadow:0 0 40px rgba(255,215,0,.8);
      max-height:70vh;overflow-y:auto;max-width:500px
    }
    #raceResults{
      position:absolute;top:100px;right:20px;background:rgba(139,69,19,.95);
      color:#fff;padding:16px;border-radius:10px;min-width:280px;
      display:none;z-index:100;box-shadow:0 5px 20px rgba(0,0,0,.4)
    }
    .result-item{
      padding:8px;margin:6px 0;background:rgba(0,0,0,.3);border-radius:6px;
      display:flex;align-items:center;gap:10px;font-size:15px
    }
    .result-position{font-weight:bold;font-size:20px;min-width:35px;text-align:center}
    .result-medal{font-size:24px}
    #loadStatus{margin-left:10px;font-size:13px}
    #toggleUI{
      position:absolute;top:20px;right:20px;background:#4CAF50;color:#fff;
      border:none;border-radius:6px;padding:10px 18px;cursor:pointer;
      transition:.2s;font-size:15px;z-index:101
    }
    #toggleUI:hover{background:#45a049}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <button id="toggleUI">Hide Settings ‚öôÔ∏è</button>

  <div id="ui">
    <h3>üèá Sprite Horse Racing</h3>
  
    <div class="row">
      <label>Frames</label>
      <input id="framesInput" type="number" min="2" max="32" />
    </div>
    <div class="row">
      <label>Scale</label>
      <input id="scaleInput" type="number" min="0.2" max="4" step="0.1" />
    </div>
    <div class="tiny">Tip: If the horse looks too small/large, change <b>Scale</b>.</div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">

    <div id="leaderboard"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üìú Race History</h4>
    <div id="raceHistory" style="max-height:200px;overflow-y:auto"></div>
    <button id="clearHistoryBtn" style="margin-top:8px;font-size:12px;padding:6px 12px">Clear History</button>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üèÜ All Horses Complete Stats</h4>
    <div id="completeStats" style="max-height:250px;overflow-y:auto;font-size:12px"></div>
    
    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <h4 style="margin:8px 0">üíæ Export Settings</h4>
    <button id="downloadRaceHistoryBtn" style="font-size:12px;padding:6px 12px;width:100%;background:#FF9800;margin-bottom:6px">Download racehistory.js</button>
  </div>

  <div id="controls">
    <button id="startBtn" disabled>Start Race</button>
    <button id="resetBtn" disabled>Reset Race</button>
    <span id="loadStatus" class="tiny">Loading sprites‚Ä¶</span>
  </div>

  <div id="winner"></div>
  <div id="raceResults"></div>

  <!-- Your horse stats -->
  <script src="horses.js"></script>
	
  <script src="race_params.js"></script>


  <script>
    /* ---------- SPRITE SETTINGS ---------- */
    const SPRITE_SRC_DEFAULT = "default.jpg";
    const SPRITE_FRAMES_DEFAULT = 6;
    const SPRITE_SCALE_DEFAULT  = 1.0;
    /* ------------------------------------ */

// Canvas & world
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// Apply track colors from horses.js
if (window.TRACK_STYLE) {
  const top = window.TRACK_STYLE.backgroundTop || '#7CB342';
  const bottom = window.TRACK_STYLE.backgroundBottom || '#558B2F';
  const border = window.TRACK_STYLE.border || '#8B4513';
  canvas.style.background = `linear-gradient(${top}, ${bottom})`;
  canvas.style.border = `8px solid ${border}`;
}



// Use params from race_params.js if available, otherwise defaults
const PARAMS = window.RACE_PARAMS || {cw:1200, ch:600, ww:5000, lg:10, lo:100, fl:4500};

canvas.width = PARAMS.cw;
canvas.height = PARAMS.ch;
const worldWidth = PARAMS.ww;
const laneGap = PARAMS.lg;
const laneOffset = PARAMS.lo;
const finishLine = PARAMS.fl;

console.log("üèá Using parameters:", PARAMS);


// === Dynamic furlong calculation ===
const START_X = 50; // same as your horse starting X
const PPF = window.RACE_PARAMS?.pixelsPerFurlong ?? 500; // pixels per furlong

// If user didn't explicitly define "furlongs" in race_params.js,
// estimate it based on finishLine distance.
const FURLONGS_TOTAL = (window.RACE_PARAMS?.furlongs)
  ?? Math.round((finishLine - START_X) / PPF);

console.log(`üìè Track length: ${FURLONGS_TOTAL} furlongs (${finishLine - START_X}px)`);

// This ensures your drawTrack() and progress calculations both adapt dynamically.




// Display parameters on screen
const paramInfo = document.createElement('div');
paramInfo.style.cssText =
  'position:fixed;top:10px;left:50%;transform:translateX(-50%);' +
  'background:rgba(0,0,0,0.8);color:lime;padding:10px;border-radius:8px;' +
  'font-family:monospace;font-size:12px;z-index:9999;';

paramInfo.innerHTML = `
‚öôÔ∏è Race Parameters:<br>
World: ${worldWidth}px | Finish: ${finishLine}px<br>
Canvas: ${canvas.width}x${canvas.height} | Lane Gap: ${laneGap}<br>
üèÅ Estimated Distance: <b>${FURLONGS_TOTAL} furlongs</b>
`;

document.body.appendChild(paramInfo);
setTimeout(() => paramInfo.remove(), 5000);


    let raceActive = false;
    let raceFinished = false;
    let cameraX = 0;
    let finishOrder = [];
    let raceHistory = []; // Store all race results
    let raceNumber = 0;

    // Load race history from racehistory.js if available
    if (window.RACE_HISTORY_DATA) {
      raceHistory = window.RACE_HISTORY_DATA.races || [];
      raceNumber = window.RACE_HISTORY_DATA.raceNumber || 0;
      console.log('Loaded race history from racehistory.js:', raceHistory.length, 'races');
    }

    // Load race history from storage on startup
    async function loadRaceHistory() {
      // Skip loading from storage if racehistory.js was already loaded
      if (window.RACE_HISTORY_DATA) {
        updateRaceHistory();
        refreshLeaderboard();
        return;
      }
      
      try {
        // Try Claude.ai storage first
        if (window.storage) {
          const result = await window.storage.get('horse-race-history');
          if (result && result.value) {
            const data = JSON.parse(result.value);
            raceHistory = data.races || [];
            raceNumber = data.raceNumber || 0;
            console.log('Loaded race history from Claude storage:', raceHistory.length, 'races');
            updateRaceHistory();
            refreshLeaderboard();
            return;
          }
        }
      } catch (error) {
        console.log('Claude storage not available, trying localStorage');
      }
      
      // Fallback to localStorage
      try {
        const stored = localStorage.getItem('horse-race-history');
        if (stored) {
          const data = JSON.parse(stored);
          raceHistory = data.races || [];
          raceNumber = data.raceNumber || 0;
          console.log('Loaded race history from localStorage:', raceHistory.length, 'races');
          updateRaceHistory();
          refreshLeaderboard();
        }
      } catch (error) {
        console.log('No previous race history found');
      }
    }

    // Save race history to storage
    async function saveRaceHistory() {
      const data = JSON.stringify({
        races: raceHistory,
        raceNumber: raceNumber
      });
      
      // Try Claude.ai storage
      try {
        if (window.storage) {
          await window.storage.set('horse-race-history', data);
          console.log('Race history saved to Claude storage');
        }
      } catch (error) {
        console.log('Claude storage not available');
      }
      
      // Always save to localStorage as backup
      try {
        localStorage.setItem('horse-race-history', data);
        console.log('Race history saved to localStorage');
      } catch (error) {
        console.error('Failed to save race history:', error);
      }
    }

    // Shared sprite config
    const spriteConfig = {
      frames: SPRITE_FRAMES_DEFAULT,
      scale:  SPRITE_SCALE_DEFAULT,
      fps:    14
    };

    // Preload the default sprite
    const horseSprite = new Image();
    horseSprite.src = SPRITE_SRC_DEFAULT;

    // Fallback colors
    const palette = [
      "#8B0000","#FFD700","#4169E1","#FF4500","#2F4F4F","#32CD32","#9932CC","#FF69B4",
      "#00CED1","#D2691E","#E6E6FA","#DC143C","#708090","#FF6347","#9ACD32","#8A2BE2",
      "#00FA9A","#FFDAB9","#FF8C00","#1E90FF","#A0522D","#ADFF2F","#00BFFF","#20B2AA"
    ];

    if (!Array.isArray(window.HORSE_DATA) || HORSE_DATA.length === 0) {
      throw new Error("HORSE_DATA is missing or empty. Make sure horses.js is loaded before this script.");
    }

    const horses = HORSE_DATA.map((h, i) => ({
      name:  h.name,
      color: h.color || palette[i % palette.length],
      lane:  i + 1,
      x: 50,
      y: laneOffset + i * laneGap,
      speed: 0,
      step: 0,
      animTime: 0,
      sprite: null,
      finished: false,
      finishTime: null,
      stats: {
        baseSpeed:  Number(h.baseSpeed),
        stamina:    Number(h.stamina),
        sprint:     Number(h.sprint),
        variance:   Number(h.variance),
        fatigue:    Number(h.fatigue),
        kick:       Number(h.kick),
        finalBoost: Number(h.finalBoost)
      }
    }));

    // Frames/Scale UI
    const framesInput = document.getElementById('framesInput');
    const scaleInput  = document.getElementById('scaleInput');
    framesInput.value = SPRITE_FRAMES_DEFAULT;
    scaleInput.value  = SPRITE_SCALE_DEFAULT;
    framesInput.oninput = () => { spriteConfig.frames = Math.max(2, Math.min(32, +framesInput.value||SPRITE_FRAMES_DEFAULT)); };
    scaleInput.oninput  = () => { spriteConfig.scale  = Math.max(0.2, Math.min(4, +scaleInput.value||SPRITE_SCALE_DEFAULT)); };

    // Track drawing
    // Track drawing with realistic racing elements
    
function drawTrack() {
  // Use colors from TRACK_STYLE or fallback to defaults
  const topColor = window.TRACK_STYLE?.backgroundTop || '#D2B48C';
  const bottomColor = window.TRACK_STYLE?.backgroundBottom || '#C19A6B';
  
  // Draw gradient background
  const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
  gradient.addColorStop(0, topColor);
  gradient.addColorStop(1, bottomColor);
  ctx.fillStyle = gradient;
  ctx.fillRect(0, 0, worldWidth, canvas.height);

  // === INNER RAIL (top border) ===
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, laneOffset - laneGap/2 - 8, worldWidth, 8);
  // Rail posts
  for (let x = 0; x < worldWidth; x += 80) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(x, laneOffset - laneGap/2 - 12, 6, 16);
  }

  // === OUTER RAIL (bottom border) ===
  const outerRailY = laneOffset - laneGap/2 + horses.length * laneGap;
  ctx.fillStyle = '#8B4513';
  ctx.fillRect(0, outerRailY, worldWidth, 8);
  // Rail posts
  for (let x = 0; x < worldWidth; x += 80) {
    ctx.fillStyle = '#654321';
    ctx.fillRect(x, outerRailY - 4, 6, 16);
  }

  // === STARTING GATE ===
  const gateX = 30;
  const gateWidth = 15;
  
  // Gate frame
  ctx.fillStyle = '#4A4A4A';
  ctx.fillRect(gateX - 5, laneOffset - laneGap/2 - 10, 5, outerRailY - (laneOffset - laneGap/2) + 20);
  ctx.fillRect(gateX + gateWidth, laneOffset - laneGap/2 - 10, 5, outerRailY - (laneOffset - laneGap/2) + 20);
  
  // Individual stall gates
  for (let i = 0; i < horses.length; i++) {
    const stallY = laneOffset - laneGap/2 + i * laneGap;
    
    // Stall divider
    ctx.fillStyle = '#666';
    ctx.fillRect(gateX - 5, stallY + laneGap - 2, gateWidth + 10, 3);
    
    // Gate door (closed before race, open during)
    if (!raceActive && !raceFinished) {
      ctx.fillStyle = 'rgba(100, 100, 100, 0.7)';
      ctx.fillRect(gateX, stallY, gateWidth, laneGap - 3);
      
      // Gate bars
      for (let b = 0; b < 4; b++) {
        ctx.fillStyle = '#888';
        ctx.fillRect(gateX + b * 4, stallY, 2, laneGap - 3);
      }
    }
    
    // Lane number on gate
    ctx.fillStyle = '#FFD700';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(i + 1, gateX + gateWidth/2, stallY + laneGap/2 + 6);
  }

  // === LANE DIVIDERS (white dashed lines) ===
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
  ctx.lineWidth = 2;
  ctx.setLineDash([10, 5]);
  for (let i = 1; i < horses.length; i++) {
    ctx.beginPath();
    ctx.moveTo(0, laneOffset - laneGap/2 + i * laneGap);
    ctx.lineTo(worldWidth, laneOffset - laneGap/2 + i * laneGap);
    ctx.stroke();
  }
  ctx.setLineDash([]);

  // === FURLONG MARKERS ===
// Use global FURLONGS_TOTAL defined above
  for (let f = 1; f <= FURLONGS_TOTAL; f++) {
    const x = 50 + (finishLine - 50) * (f / FURLONGS_TOTAL);
    
    ctx.save();
    // Marker pole
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 3;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.moveTo(x, laneOffset - laneGap / 2);
    ctx.lineTo(x, outerRailY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Furlong pole top
    ctx.fillStyle = '#fff';
    ctx.fillRect(x - 3, laneOffset - laneGap / 2 - 20, 6, 16);
    
    // Furlong number
    ctx.font = 'bold 22px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = '#0066cc';
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 3;
    ctx.strokeText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
    ctx.fillText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
    ctx.restore();
  }

  // === FINISH LINE ===
  const finishWidth = 35;
  
  // Red finish post
  ctx.fillStyle = '#CC0000';
  ctx.fillRect(finishLine - 3, 0, 6, canvas.height);
  
  // Checkered pattern
  const checkerSize = 20;
  for (let y = 0; y < canvas.height; y += checkerSize) {
    for (let x = 0; x < finishWidth; x += checkerSize) {
      const isBlack = ((x / checkerSize) + (y / checkerSize)) % 2 === 0;
      ctx.fillStyle = isBlack ? '#000' : '#fff';
      ctx.fillRect(finishLine + 3, y, checkerSize, checkerSize);
      ctx.fillRect(finishLine + 3 + checkerSize, y, checkerSize, checkerSize);
    }
  }
  
  // Finish line banner
  ctx.fillStyle = 'rgba(204, 0, 0, 0.9)';
  ctx.fillRect(finishLine - 20, 10, finishWidth + 40, 35);
  ctx.fillStyle = '#FFD700';
  ctx.font = 'bold 24px Arial';
  ctx.textAlign = 'center';
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 4;
  ctx.strokeText('FINISH', finishLine + finishWidth/2 - 10, 32);
  ctx.fillText('FINISH', finishLine + finishWidth/2 - 10, 32);

  // === DISTANCE MARKERS ON TRACK ===
  // Starting line
  ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
  ctx.fillRect(48, laneOffset - laneGap/2, 4, outerRailY - (laneOffset - laneGap/2));
}
  






// Sprite drawing with proper color tinting
function drawHorseSprite(horse, dt) {
  const { frames, scale, fps } = spriteConfig;
  const hasSprite = horse.sprite && horse.sprite.img && horse.sprite.img.complete;

  function drawName(yOffset){
    ctx.font = 'bold 14px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'bottom';
    ctx.strokeStyle = 'rgba(0,0,0,0.6)';
    ctx.lineWidth = 4;
    ctx.strokeText(horse.name, 0, yOffset);
    ctx.fillStyle = '#fff';
    ctx.fillText(horse.name, 0, yOffset);
  }

  // Use default sprite if present
  if (!hasSprite && horseSprite.complete) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    const animFps = fps + horse.speed * 0.6;
    horse.animTime = (horse.animTime || 0) + animFps * dt;
    const frameWidth  = horseSprite.width / SPRITE_FRAMES_DEFAULT;
    const frameHeight = horseSprite.height;
    const frame       = Math.floor(horse.animTime) % SPRITE_FRAMES_DEFAULT;
    const drawWidth  = frameWidth  * SPRITE_SCALE_DEFAULT;
    const drawHeight = frameHeight * SPRITE_SCALE_DEFAULT;
    
    // Create temporary canvas for tinting
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = drawWidth;
    tempCanvas.height = drawHeight;
    
    // Draw horse to temp canvas
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    // Apply color tint using multiply blend
    tempCtx.globalCompositeOperation = 'multiply';
    tempCtx.fillStyle = horse.color;
    tempCtx.fillRect(0, 0, drawWidth, drawHeight);
    
    // Restore original alpha channel (removes background tinting)
    tempCtx.globalCompositeOperation = 'destination-in';
    tempCtx.drawImage(
      horseSprite,
      frame * frameWidth, 0, frameWidth, frameHeight,
      0, 0, drawWidth, drawHeight
    );
    
    tempCtx.globalCompositeOperation = 'source-over';
    
    // Draw tinted horse
    ctx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2 - 22);
    
    drawName(-drawHeight * 0.6);
    ctx.restore();
    return;
  }

  // Fallback circle (already uses color)
  if (!hasSprite) {
    ctx.save();
    ctx.translate(horse.x, horse.y);
    ctx.fillStyle = horse.color;
    ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(horse.lane, 0, 0);
    drawName(-30);
    ctx.restore();
    return;
  }

  // Custom sprite with color tint
  const img = horse.sprite.img;
  const frameW = Math.floor(img.width / frames);
  const frameH = img.height;
  const animFps = fps + horse.speed * 0.6;
  horse.animTime = (horse.animTime || 0) + animFps * dt;
  const frameIndex = Math.floor(horse.animTime) % frames;
  const drawW = frameW * scale;
  const drawH = frameH * scale;

  ctx.save();
  ctx.translate(horse.x, horse.y);
  
  // Create temporary canvas for tinting
  const tempCanvas = document.createElement('canvas');
  const tempCtx = tempCanvas.getContext('2d');
  tempCanvas.width = drawW;
  tempCanvas.height = drawH;
  
  // Draw sprite frame
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  // Apply color tint
  tempCtx.globalCompositeOperation = 'multiply';
  tempCtx.fillStyle = horse.color;
  tempCtx.fillRect(0, 0, drawW, drawH);
  
  // Restore transparency
  tempCtx.globalCompositeOperation = 'destination-in';
  tempCtx.drawImage(
    img,
    frameIndex * frameW, 0, frameW, frameH,
    0, 0, drawW, drawH
  );
  
  tempCtx.globalCompositeOperation = 'source-over';
  
  // Draw tinted result
  ctx.drawImage(tempCanvas, -drawW*0.5, -drawH*0.5);

  drawName(-drawH * 0.6);
  ctx.restore();
}















    // Leaderboard & results
    const leaderboard = document.getElementById('leaderboard');
    const raceResults = document.getElementById('raceResults');
    const raceHistoryEl = document.getElementById('raceHistory');

  function refreshLeaderboard() {
  const sorted = [...horses].sort((a,b) => b.x - a.x);
  let html = '<h4 style="margin:8px 0">üèá Current Standings</h4>';
  sorted.forEach((h,i) => {
    const pct = Math.max(0, Math.round((h.x / finishLine) * 100));
    
    // Build race code
    let raceCode = '';
    raceHistory.forEach(race => {
      const result = race.results.find(r => r.name === h.name);
      if (result) {
        raceCode += result.position >= 10 ? '0' : result.position;
      }
    });
    const displayCode = raceCode || '----';
    
    // ADD STRATEGY BADGE
    const strategyBadge = h.strategy 
      ? `<span style="background:${getStrategyColor(h.strategy)};color:white;padding:2px 6px;border-radius:4px;font-size:10px;font-weight:bold;margin-left:5px">${h.strategy}</span>`
      : '';
    
    // FIXED: Show everything in ONE div (not two!)
    html += `<div class="horse-info">
      ${i+1}. <b>${h.name}</b> ${strategyBadge} ‚Äî Lane ${h.lane} ‚Äî <span style="color:${h.color}">‚óè</span> ${pct}%
      <div class="tiny">Race history: ${displayCode}</div>
    </div>`;
  });
  leaderboard.innerHTML = html;
}

// ADD THIS HELPER FUNCTION
function getStrategyColor(strategy) {
  switch(strategy) {
    case 'FRONT_RUNNER': return '#ff4444';
    case 'PRESSER': return '#ff9800';
    case 'STALKER': return '#2196F3';
    case 'CLOSER': return '#9c27b0';
    default: return '#666';
  }
}


function showStrategySummary(horses) {
  const counts = { FRONT_RUNNER: 0, PRESSER: 0, STALKER: 0, CLOSER: 0 };
  horses.forEach(h => counts[h.strategy] = (counts[h.strategy] || 0) + 1);

  const getColor = getStrategyColor; // reuse your existing color function

  // Build small summary panel
  const summaryHTML = `
    <div id="strategySummary" style="
      background:rgba(0,0,0,0.2);
      padding:10px;
      margin:8px 0;
      border-radius:6px;
      font-size:13px;">
      <div style="font-weight:bold;margin-bottom:4px;">üèá Strategy Mix</div>
      ${Object.entries(counts).map(([name,count]) =>
        `<div style="margin:2px 0;">
          <span style="display:inline-block;width:12px;height:12px;background:${getColor(name)};border-radius:3px;margin-right:6px;"></span>
          ${name.replace('_',' ')}: <b>${count}</b>
        </div>`).join('')}
    </div>
  `;

  const leaderboard = document.getElementById('leaderboard');
  if (leaderboard) {
    // Remove previous summary if it exists
    const existing = document.getElementById('strategySummary');
    if (existing) existing.remove();

    // Insert before leaderboard section
    leaderboard.insertAdjacentHTML('beforebegin', summaryHTML);
  }
}



    function updateRaceHistory() {
      if (raceHistory.length === 0) {
        raceHistoryEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        updateCompleteStats();
        return;
      }
      
      let html = '';
      raceHistory.slice().reverse().forEach((race, idx) => {
        const actualRaceNum = raceHistory.length - idx;
        html += `<div style="background:rgba(0,0,0,0.2);padding:8px;margin:6px 0;border-radius:6px">
          <div style="font-weight:bold;margin-bottom:4px">Race #${actualRaceNum}</div>
          <div style="font-size:12px">`;
        
        race.results.forEach(r => {
          const medal = r.position === 1 ? 'ü•á' : r.position === 2 ? 'ü•à' : r.position === 3 ? 'ü•â' : '';
          html += `<div style="padding:2px 0">
            ${medal} ${r.position}. <span style="color:${r.color}">‚óè</span> ${r.name} (L${r.lane})
          </div>`;
        });
        
        html += `</div></div>`;
      });
      
      raceHistoryEl.innerHTML = html;
      updateCompleteStats();
    }

    function updateCompleteStats() {
      const completeStatsEl = document.getElementById('completeStats');
      
      if (raceHistory.length === 0) {
        completeStatsEl.innerHTML = '<div class="tiny" style="opacity:0.7">No races completed yet</div>';
        return;
      }

      let html = '<div style="background:rgba(0,0,0,0.2);padding:8px;border-radius:6px">';
      
      horses.forEach(h => {
        // Build race code for this horse
        let raceCode = '';
        raceHistory.forEach(race => {
          const result = race.results.find(r => r.name === h.name);
          if (result) {
            raceCode += result.position >= 10 ? '0' : result.position;
          }
        });
        
        if (raceCode) {
          html += `<div style="padding:4px 0;border-bottom:1px solid rgba(255,255,255,0.1)">
            <span style="color:${h.color};font-size:16px">‚óè</span> 
            <b>${h.name}</b> - ${raceCode}
          </div>`;
        }
      });
      
      html += '</div>';
      completeStatsEl.innerHTML = html;
    }

    function updateRaceResults() {
      if (!raceActive && finishOrder.length === 0) {
        raceResults.style.display = 'none';
        return;
      }
      raceResults.style.display = 'block';
      let html = '<h3 style="margin:0 0 10px 0; font-size:18px;">üìä Race Results</h3>';

      if (finishOrder.length > 0) {
        finishOrder.forEach((h, i) => {
          const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
          html += `<div class="result-item">
            <span class="result-position">${i+1}${getOrdinalSuffix(i+1)}</span>
            ${medal ? `<span class="result-medal">${medal}</span>` : ''}
            <span style="color:${h.color};font-size:20px">‚óè</span>
            <span style="flex:1"><b>${h.name}</b><br/><small>Lane ${h.lane}</small></span>
          </div>`;
        });
      }

      const stillRacing = horses.filter(h => !h.finished);
      if (stillRacing.length > 0) {
        html += '<div style="margin-top:10px;padding-top:10px;border-top:1px solid rgba(255,255,255,0.3)">';
        html += '<div style="font-size:13px;opacity:0.8;margin-bottom:6px">Still Racing:</div>';
        stillRacing.forEach(h => {
          const pct = Math.max(0, Math.min(100, Math.round((h.x / finishLine) * 100)));
          html += `<div style="padding:4px;margin:3px 0;font-size:13px">
            <span style="color:${h.color}">‚óè</span> ${h.name} - ${pct}%
          </div>`;
        });
        html += '</div>';
      }
      raceResults.innerHTML = html;
    }

    function getOrdinalSuffix(num) {
      const j = num % 10, k = num % 100;
      if (j === 1 && k !== 11) return 'st';
      if (j === 2 && k !== 12) return 'nd';
      if (j === 3 && k !== 13) return 'rd';
      return 'th';
    }

   
    // Race control
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const loadStatus = document.getElementById('loadStatus');

    function startRace() {
      if (raceActive) return;
      raceActive = true;
      raceFinished = false;
      finishOrder = [];
      horses.forEach(h => {
        h.finished = false;
        h.finishTime = null;
        h._lateKickUsed = false;
        h._finalBoostUsed = false;
        h._kickTimer = 0;
        h._kickCooldown = 0;
      });

      assignRacingStrategies(horses); // ‚≠ê ADD THIS LINE

      startBtn.disabled = true;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'block';
      lastTs = performance.now();
    }

    function resetRace() {
      raceActive = false;
      raceFinished = false;
      cameraX = 0;
      finishOrder = [];
      horses.forEach(h=>{
        h.x=50; h.speed=0; h.step=0; h.animTime=0;
        h.y = laneOffset + (h.lane-1)*laneGap;
        h._kickTimer = 0;
        h._kickCooldown = 0;
        h._finalBoostUsed = false;
        h._lateKickUsed = false;
        h.finished = false;
        h.finishTime = null;
      });
      startBtn.disabled = false;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      raceResults.style.display = 'none';
      refreshLeaderboard();
    }



// ============================================
// UPDATE YOUR updateHorses() FUNCTION:
// Replace the physics calculation part with this
// ============================================

function updateHorses(dt) {
  if (!raceActive) return;

  // Precompute leader once per tick
  const leaderXGlobal = Math.max(...horses.map(hh => hh.x));

  horses.forEach(h => {
    const prog = Math.min(1, (h.x - 50) / (finishLine - 50)); // 0..1 race progress
    
    // ‚úÖ ADD THESE TWO LINES RIGHT HERE:
    const totalF = FURLONGS_TOTAL;                     // total furlongs this race (computed earlier)
    const curF   = Math.max(0, Math.min(totalF, (h.x - START_X) / PPF)); // clamp 0..totalF
    // --- Phase pacing (uses strategyParams + kickPhase) ---
    const sp = h.strategyParams || {};
    const earlyPace = sp.earlyPace ?? 0.9;
    const midPace   = sp.midPace   ?? 0.9;
    const latePace  = sp.latePace  ?? 0.95;
    const kickPhase = sp.kickPhase ?? 0.80;

    let paceTarget;
    if (prog < 0.33) {
      paceTarget = earlyPace;
    } else if (prog < Math.min(0.70, kickPhase)) {
      paceTarget = midPace;
    } else if (prog >= kickPhase) {
      paceTarget = latePace; // KICK phase
    } else {
      paceTarget = midPace;
    }

    // --- Base speed with strategy phase ---
    const baseSpeed = h.stats.baseSpeed * paceTarget;

    // --- Stamina effect (ramps up with distance) ---
// === 1) Harsher stamina scaling for long trips ===
// make stamina cost grow with total distance; hurts early leaders in marathons
const longness = Math.min(1, Math.max(0, (totalF - 12) / 12)); // 0 at <=12f, ‚Üí1 by 24f
const staminaPower = 1.8 + 0.6 * longness; // was ~1.8; now up to 2.4 on 24f
const staminaEffect = Math.pow(h.stats.stamina, staminaPower * prog);

    // --- Fatigue/pressure from leading (leader pays a tax) ---
    const isLeading = h.x >= leaderXGlobal - 5;
    const energyDrain = sp.energyDrain ?? 1.1;
    // Start applying leader pressure around halfway; scale with prog
    const tired = 1 - h.stats.fatigue * Math.max(0, prog - 0.5) * (isLeading ? energyDrain : 1.0);

    // --- Random variance (soft-capped to keep packs tight) ---
    const rawJitter = (Math.random() - 0.5) * (h.stats.variance ?? 0.1);
    const jitter = Math.max(-0.08, Math.min(0.08, rawJitter)); // clamp ¬±0.08

    // --- Initial speed before kick/surge logic ---
    let s = baseSpeed * staminaEffect * tired + jitter;

    // === 2) Leader drag that ramps with distance and race progress ===
// Compute second place X to measure "clear lead"
const sortedX = horses.map(o => o.x).sort((a,b)=>b-a);
const leaderX = sortedX[0] || 0;
const secondX = sortedX[1] || leaderX;
const oneLengthPx = Math.max(1, (h.stats.baseSpeed || 1) * 12);
const leadGapLengths = (leaderX - secondX) / oneLengthPx;

// If you're the leader, pay a growing tax, bigger in long races and late in race
if (h.x >= leaderX - 5) {
  // base leader tax grows with progress and longness; extra if clear by >2L
  const baseLeaderTax = 1 + 0.10*prog + 0.15*longness;     // up to ~+0.25
  const clearLeadTax  = leadGapLengths > 2 ? 0.05*Math.min(4,(leadGapLengths-2)) : 0;
  const leaderDrag    = 1 - Math.min(0.28, (baseLeaderTax - 1) + clearLeadTax); // cap 28%
  s *= leaderDrag;
} else {
  // === 3) Pack/drafting assist for everyone NOT leading ===
  // Find nearest horse ahead to draft off (within ~1‚Äì4 lengths)
  let nearestAheadPx = Infinity;
  for (const o of horses) {
    if (o === h) continue;
    if (o.x > h.x) nearestAheadPx = Math.min(nearestAheadPx, o.x - h.x);
  }
  const nearestAheadL = nearestAheadPx / oneLengthPx;

  if (nearestAheadL >= 1 && nearestAheadL <= 4) {
    // Base drafting boost; slightly stronger in long races and mid-late phases
    const draftBase = 0.02 + 0.03*longness + 0.02*Math.min(1, (prog-0.3)/0.5); // up to ~7%
    // Stalkers get more value from draft
    const stratBonus = h.strategy === 'STALKER' ? 0.02 : 0.0;
    s *= 1 + Math.min(0.10, draftBase + stratBonus);
  }

  // Gentle elastic catch-up if you‚Äôre >4 lengths behind leader, bigger in long races and late
  const gapBehindLeaderL = (leaderX - h.x) / oneLengthPx;
  if (gapBehindLeaderL > 4) {
    const elastic = Math.min(0.12, 0.03 + 0.05*longness + 0.05*Math.max(0, prog-0.5));
    s *= (1 + elastic);
  }
}


    // --- Kick bursts (your existing logic, kept) ---
    if (h._kickCooldown == null) h._kickCooldown = 0;
    if (h._kickTimer == null)    h._kickTimer    = 0;
    h._kickCooldown -= dt;
    h._kickTimer = Math.max(0, h._kickTimer - dt);

    if (h._kickCooldown <= 0 && Math.random() < 0.015 * h.stats.kick) {
      h._kickTimer = 0.6 + 0.8 * h.stats.kick;
      h._kickCooldown = 2.0 + Math.random() * 2.0;
    }

    if (prog > 0.82 && h._kickTimer === 0 && !h._lateKickUsed) {
      h._kickTimer = 0.7 + 0.9 * h.stats.kick;
      h._lateKickUsed = true;
    }

    const kickBoost = h._kickTimer > 0
      ? 1 + (0.20 + 0.80 * h.stats.kick) * (1 - prog * 0.3)
      : 1;
    s *= kickBoost;

    // --- STALKER: stronger mid/late catch-up + drafting + late steadiness ---
if (h.strategy === 'STALKER') {
  const behindPx = leaderXGlobal - h.x;

  // heuristic "length" size in px (based on each horse's baseline)
  const oneLengthPx = Math.max(1, (h.stats.baseSpeed || 1) * 12);
  const gapLengths  = behindPx / oneLengthPx;

  // (A) Mid-race catch-up (buffed: up to +12%)
  if (prog > 0.26 && prog < 0.78 && gapLengths > 0.6) {
    // base + scaled by how far back; capped
    const gain = Math.min(0.12, 0.03 + 0.035 * (gapLengths - 0.6));
    s *= (1 + gain);
  }

  // (B) Drafting when within ~1‚Äì4 lengths of any horse ahead (buffed)
  const nearestAheadPx = horses.reduce((min, o) => {
    if (o === h || o.x <= h.x) return min;
    const d = o.x - h.x;
    return d < min ? d : min;
  }, Infinity);

  if (nearestAheadPx < 4 * oneLengthPx) {
    // closer = more slipstream
    const slip = Math.max(0, 1 - (nearestAheadPx / (4 * oneLengthPx))); // 0..1
    s *= 1 + 0.02 + slip * 0.05; // up to ~+7%
    
    // Slingshot in the closing 6f if still behind a little
    if ((totalF - curF) <= 6 && gapLengths > 0.3 && gapLengths < 2.5) {
      s *= 1.03;
    }
  }

  // (C) Late steadiness (buffed)
  if (prog > 0.80) {
    s *= 1.07;
  }

  // (D) Mid-late fatigue guard (keeps them from sagging)
  if (prog > 0.55 && prog < 0.88) {
    s *= 1.03;
  }
}


    // --- PRESSER late surge (gap-aware) ---
    if (h.strategy === 'PRESSER') {
      const surgeWindow  = sp.surgeWindow ?? 0.18; // last 18% of race
      const gapTrigger   = sp.gapTrigger  ?? 0.6;  // lengths behind before surge assist
      const kickMult     = sp.kickMult    ?? 1.12; // base kick multiplier for pressers

      // Start building earlier for pressers
      if (prog >= (sp.kickPhase ?? 0.70)) {
        s *= kickMult;

        // If still behind in final surge window, add capped catch-up
        if (prog >= (1 - surgeWindow)) {
          // convert px gap to "lengths"
          const gapPx = leaderXGlobal - h.x;
          const oneLengthPx = Math.max(1, (h.stats.baseSpeed || 1) * 12); // heuristic
          const gapLengths = gapPx / oneLengthPx;

          if (gapLengths > gapTrigger) {
            // smooth, bounded catch-up: stronger if farther back, capped
            const catchUp = Math.min(1.12, 1 + 0.06 * Math.tanh(gapLengths - gapTrigger));
            s *= catchUp;
          }
        }
      }
    }

// --- CLOSER: long-run ramping boost from 12f to race end (targeting 24f scale) ---
// --- 4) CLOSER: long-run ramping boost from 12f to end, stronger near 24f ---
if (h.strategy === 'CLOSER') {
  if (curF >= 12 && totalF > 12) {
    const longPhase = Math.min(1, (curF - 12) / Math.max(1, (totalF - 12))); // 0..1
    // scale with longness; allow bigger ceiling on true marathons
    const maxLongBoost = (0.35 + 0.20*longness) * (0.85 + 0.3 * (h.stats.finalBoost || 1));
    const longMult = 1 + longPhase * maxLongBoost;
    s *= Math.min(longMult, 1.55); // hard cap ~+55%
  }
}


    if (h._finalBoostUsed && prog > 0.9) {
      s *= 1.0 - (prog - 0.9) * 0.15; // taper off
    }

    // --- Safety floors & motion ---
    h.speed = Math.max(0.8, s);
    h.x += h.speed;
    h.step += h.speed * 0.08;

    // --- Finish detection (unchanged) ---
    if (h.x >= finishLine && !h.finished) {
      h.finished = true;
      h.finishTime = performance.now();
      finishOrder.push({
        name: h.name,
        lane: h.lane,
        color: h.color,
        position: finishOrder.length + 1,
        strategy: h.strategy
      });

      if (finishOrder.length === horses.length) {
        raceFinished = true;
        raceActive = false;
        showResults();
      }
    }

    if (h.finished && h.x > finishLine + 100) {
      h.speed *= 0.95;
    }
  });

  refreshLeaderboard();
  updateRaceResults();
}








    function shuffleLanes() {
      const ids = horses.map((_, i) => i + 1).sort(() => Math.random() - 0.5);
      horses.forEach((h,i) => {
        h.lane = ids[i];
        h.y = laneOffset + (h.lane-1)*laneGap;
      });
      refreshLeaderboard();
    }

    function showResults() {
      const el = document.getElementById('winner');
      let html = `<div style="font-size:28px; margin-bottom:16px;">üèÜ RACE COMPLETE üèÜ</div>`;
      html += '<div style="text-align:left;">';
      finishOrder.forEach((h, i) => {
        const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : '';
        html += `<div style="margin:10px 0; font-size:${22-i*1.5}px; padding:8px; background:rgba(139,69,19,0.3); border-radius:6px;">
          ${medal} <b>${i+1}${getOrdinalSuffix(i+1)}</b> - <span style="color:${h.color}">‚óè</span> ${h.name} <small style="opacity:0.8">(Lane ${h.lane})</small>
        </div>`;
      });
      html += '</div>';
      el.innerHTML = html;
      el.style.display = 'block';
      resetBtn.disabled = false;
      startBtn.disabled = true;
      
      // Save race to history
      raceNumber++;
      raceHistory.push({
        raceNum: raceNumber,
        results: finishOrder.map((h, i) => ({
          position: i + 1,
          name: h.name,
          lane: h.lane,
          color: h.color
        }))
      });
      updateRaceHistory();
      refreshLeaderboard(); // Update to show new "last race" positions
      saveRaceHistory(); // Save to storage
    }

    function refreshButtonsIfLoaded() {
      const allReady = horseSprite.complete || horses.some(h => h.sprite?.img?.complete);
      startBtn.disabled   = !allReady;
      resetBtn.disabled   = true;
      loadStatus.textContent = allReady ? "Sprites loaded. Ready to race!" : "Loading sprites‚Ä¶";
    }
    horseSprite.onload = refreshButtonsIfLoaded;

    // Game loop with camera tracking
    let lastTs = performance.now();
    function loop(ts) {
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;

      if (raceActive || raceFinished) {
        const leader = Math.max(...horses.map(h => h.x));
        const targetCameraX = Math.max(0, Math.min(worldWidth - canvas.width, leader - canvas.width * 0.3));
        cameraX += (targetCameraX - cameraX) * 0.1;
      }

      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.translate(-cameraX, 0);

      drawTrack();
      horses.slice().sort((a,b)=>a.y-b.y).forEach(h => drawHorseSprite(h, dt));

      ctx.restore();

      updateHorses(dt);
      requestAnimationFrame(loop);
    }

    // Buttons
    startBtn.onclick = startRace;
    resetBtn.onclick = resetRace;
        
    document.getElementById('clearHistoryBtn').onclick = () => {
      if (confirm('Clear all race history?')) {
        raceHistory = [];
        raceNumber = 0;
        updateRaceHistory();
        refreshLeaderboard();
        saveRaceHistory(); // Save cleared state
      }
    };


// Dynamic Strategy Assignment System
// Assigns strategies based on how each horse compares to the AVERAGE of the race field

function assignRacingStrategies(horses) {
  // === STEP 1: calculate averages ===
  const avg = {
    speed:  horses.reduce((a,b)=>a+b.stats.baseSpeed,0) / horses.length,
    stamina:horses.reduce((a,b)=>a+b.stats.stamina,0) / horses.length,
    sprint: horses.reduce((a,b)=>a+b.stats.sprint,0) / horses.length
  };

  const raceLength = finishLine - 50;
  const isShort = raceLength < 3000;
  const isLong  = raceLength > 6000;

  // === STEP 2: calculate suitability scores for each strategy ===
  const scores = horses.map(h => {
    const r = {
      speed:   h.stats.baseSpeed / avg.speed,
      stamina: h.stats.stamina   / avg.stamina,
      sprint:  h.stats.sprint    / avg.sprint
    };
    return {
      horse: h,
      scores: {
        FRONT_RUNNER: r.speed * 1.5 + r.stamina * 0.8 - r.sprint * 0.3,
        PRESSER:      r.speed * 1.1 + r.stamina * 1.0 + r.sprint * 0.8,
        STALKER:      3 - (Math.abs(r.speed-1) + Math.abs(r.stamina-1) + Math.abs(r.sprint-1)),
        CLOSER:       r.sprint * 1.6 + r.stamina * 1.1 - r.speed * 0.4
      }
    };
  });

    // === STEP 3EQUAL: guarantee an equal mix across strategies ===
  const STRATS = ['FRONT_RUNNER','PRESSER','STALKER','CLOSER'];
  const assigned = new Map();
  const used     = new Set();
  const n        = horses.length;

  // helper: pick the best remaining horse for a given strategy
  function bestHorseFor(strategy) {
    const pick = scores
      .filter(s => !used.has(s.horse))
      .map(s => ({ horse: s.horse, score: s.scores[strategy] }))
      .sort((a,b) => b.score - a.score)[0];
    return pick || null;
  }

  // If <= 4 horses, give each a different strategy first
  if (n <= STRATS.length) {
    for (let i = 0; i < n; i++) {
      const st = STRATS[i];
      const pick = bestHorseFor(st);
      if (pick) { assigned.set(pick.horse, st); used.add(pick.horse); }
    }
  } else {
    // Equal target per strategy (base), remainder spread by strength
    const base = Math.floor(n / STRATS.length); // e.g. 16 -> 4 each
    let rem    = n % STRATS.length;             // leftovers to distribute

    // Which strategies are strongest overall (by their top available score)?
    const stratStrength = STRATS.map(st => {
      const top = scores.map(s => s.scores[st]).sort((a,b)=>b-a)[0] ?? -Infinity;
      return { st, top };
    }).sort((a,b) => b.top - a.top);

    const targets = {};
    STRATS.forEach(st => targets[st] = base);
    for (let i = 0; i < rem; i++) targets[stratStrength[i].st] += 1;

    // helper: how many already assigned to st?
    function assignedPer(st) {
      let c = 0; for (const [,v] of assigned) if (v === st) c++; return c;
    }

    // Fill each bucket up to its target
    for (const st of STRATS) {
      while (assignedPer(st) < targets[st]) {
        const pick = bestHorseFor(st);
        if (!pick) break;
        assigned.set(pick.horse, st);
        used.add(pick.horse);
      }
    }

    // Anything left unassigned ‚Üí drop into their personal best strategy
    scores.forEach(s => {
      if (!assigned.has(s.horse)) {
        const best = Object.entries(s.scores).sort((a,b)=>b[1]-a[1])[0][0];
        assigned.set(s.horse, best);
        used.add(s.horse);
      }
    });
  }

  // Write back chosen strategies
  horses.forEach(h => { h.strategy = assigned.get(h) || h.strategy; });

  // === STEP 5: apply tuned strategy parameters ===
  horses.forEach(h => {
    const r = {
      speed:   h.stats.baseSpeed / avg.speed,
      stamina: h.stats.stamina   / avg.stamina,
      sprint:  h.stats.sprint    / avg.sprint
    };

    switch(h.strategy) {
      case 'FRONT_RUNNER':
        h.strategyParams = {
          earlyPace: isLong ? 0.88 : (isShort ? 0.98 : 0.93),
          midPace:   isLong ? 0.83 : 0.88,
          latePace:  isLong ? 0.78 : 0.82,
          energyDrain: isLong ? 1.25 : 1.15,
          kickPhase: isLong ? 0.90 : 0.85
        };
        break;
      case 'PRESSER':
        h.strategyParams = {
          earlyPace: 0.82,
          midPace:   isLong ? 0.88 : 0.90,
          latePace:  isLong ? 1.05 : 1.02,
          energyDrain: 1.1,
          kickPhase: 0.72,
          kickMult: 1.08,
          surgeWindow: 0.15,
          gapTrigger: 0.8
        };
        break;
      case 'STALKER':
        h.strategyParams = {
          earlyPace: 0.80,
          midPace:   isLong ? 0.92 : 0.88,
          latePace:  isLong ? 1.12 : 1.08,
          energyDrain: 0.93,
          kickPhase: 0.72
        };
        break;
      case 'CLOSER':
        h.strategyParams = {
          earlyPace: isShort ? 0.78 : 0.68,
          midPace:   isLong ? 0.78 : 0.76,
          latePace:  isLong ? 1.35 : 1.22,
          energyDrain: 0.70,
          kickPhase: isShort ? 0.75 : 0.80
        };
        break;
    }
  });

  // === STEP 6: log for debugging ===
  const dist = {};
  horses.forEach(h => dist[h.strategy] = (dist[h.strategy]||0)+1);
  console.log('üìä Final strategy distribution:', dist);
  horses.forEach(h => console.log(`üê¥ ${h.name.padEnd(20)} ‚Üí ${h.strategy}`));
  showStrategySummary(horses);
}








    // Download racehistory.js
    document.getElementById('downloadRaceHistoryBtn').onclick = () => {
      const jsContent = `// Race History Data
// This file stores all completed race results

window.RACE_HISTORY_DATA = {
  raceNumber: ${raceNumber},
  races: ${JSON.stringify(raceHistory, null, 2)}
};
`;

      const blob = new Blob([jsContent], { type: 'text/javascript' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'racehistory.js';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('racehistory.js downloaded! Add this line to your HTML before the main script tag.');
    };

 

    // Toggle UI visibility
    const toggleUIBtn = document.getElementById('toggleUI');
    const uiPanel = document.getElementById('ui');
    uiPanel.classList.add('hidden'); // start hidden
    
    toggleUIBtn.onclick = () => {
      uiPanel.classList.toggle('hidden');
      toggleUIBtn.textContent = uiPanel.classList.contains('hidden') ? 'Show Settings ‚öôÔ∏è' : 'Hide Settings ‚öôÔ∏è';
    };

    // Kick off
    loadRaceHistory(); // Load saved history
    refreshButtonsIfLoaded();
    refreshLeaderboard();
    updateRaceHistory();
    requestAnimationFrame(loop);
  </script>
</body>
</html>