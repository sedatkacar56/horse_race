<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Horse Racing (Sprite Sheet)</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:Arial,Helvetica,sans-serif;background:linear-gradient(#87CEEB,#98D98E);overflow:hidden}
    #gameCanvas{display:block;margin:20px auto;background:linear-gradient(#7CB342,#558B2F);border:5px solid #8B4513;box-shadow:0 10px 30px rgba(0,0,0,.3)}
    #ui{
      position:absolute;top:20px;left:20px;background:rgba(139,69,19,.92);
      color:#fff;padding:14px;border-radius:10px;min-width:320px;max-width:380px;
      max-height:80vh;overflow-y:auto;z-index:100
    }
    .row{display:flex;gap:8px;align-items:center;margin:6px 0}
    .row label{min-width:64px;font-size:13px}
    .row input[type="text"], .row input[type="number"]{
      flex:1;border:none;border-radius:6px;padding:6px 8px;outline:none;font-size:13px
    }
    .row input[type="file"]{flex:1}
    .tiny{font-size:12px;opacity:.9}
    .horse-info{background:rgba(0,0,0,.25);padding:6px 8px;border-radius:6px;margin:8px 0}
    #controls{
      position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
      background:rgba(139,69,19,.92);color:#fff;border-radius:10px;padding:14px 16px;
      display:flex;flex-wrap:wrap;gap:10px;justify-content:center;align-items:center
    }
    button{
      background:#4CAF50;color:#fff;border:none;border-radius:6px;padding:10px 18px;
      cursor:pointer;transition:.2s;font-size:15px
    }
    button:hover{background:#45a049;transform:scale(1.05)}
    button:disabled{background:#666;transform:none;cursor:not-allowed}
    #winner{
      position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
      background:rgba(255,215,0,.96);padding:28px;border-radius:14px;font-weight:700;
      color:#8B4513;display:none;text-align:center;font-size:22px;box-shadow:0 0 40px rgba(255,215,0,.8)
    }
    #loadStatus{margin-left:10px;font-size:13px}
    #toggleUI{
      position:absolute;top:20px;right:20px;background:#4CAF50;color:#fff;
      border:none;border-radius:6px;padding:10px 18px;cursor:pointer;
      transition:.2s;font-size:15px;z-index:101
    }
    #toggleUI:hover{background:#45a049}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <button id="toggleUI">Hide Settings ‚öôÔ∏è</button>

  <div id="ui" class="hidden">
    <h3>üèá Sprite Horse Racing</h3>

    <div class="tiny" style="margin-bottom:8px">
      This page auto-loads <b>default.jpg</b> (6 frames, one row). You can override any horse with your own PNG/JPG.
    </div>

    <div class="row">
      <label>Frames</label>
      <input id="framesInput" type="number" min="2" max="32" />
    </div>
    <div class="row">
      <label>Scale</label>
      <input id="scaleInput" type="number" min="0.2" max="4" step="0.1" />
    </div>
    <div class="tiny">Tip: If the horse looks too small/large, change <b>Scale</b>.</div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">

    <div id="horseConfig"></div>

    <hr style="border:none;height:1px;background:rgba(255,255,255,.25);margin:10px 0">
    <div id="leaderboard"></div>
  </div>

  <div id="controls">
    <button id="startBtn" disabled>Start Race</button>
    <button id="resetBtn" disabled>Reset Race</button>
    <button id="shuffleBtn" disabled>Shuffle Lanes</button>
    <span id="loadStatus" class="tiny">Loading sprites‚Ä¶</span>
  </div>

  <div id="winner"></div>

  <script>
    // ---------- YOUR SPRITE SETTINGS ----------
    const SPRITE_SRC_DEFAULT = "default.jpg";
    const SPRITE_FRAMES_DEFAULT = 6;
    const SPRITE_SCALE_DEFAULT  = 1.0;
    // -----------------------------------------

    // Canvas & world
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 1200;  // Viewport width
    canvas.height = 600;
    const worldWidth = 5000;  // Total track length

    const laneGap = 10;
    const laneOffset = 100;
    const finishLine = 4500;

    let raceActive = false;
    let raceFinished = false;
    let cameraX = 0;

    // Shared sprite config
    const spriteConfig = {
      frames: SPRITE_FRAMES_DEFAULT,
      scale:  SPRITE_SCALE_DEFAULT,
      fps:    14
    };

    // Preload the default sprite
    const horseSprite = new Image();
    horseSprite.src = SPRITE_SRC_DEFAULT;

    // Horses with stats
    const horses = [
      { name:'Thunder',   lane:1, color:'#8B0000', x:50, y:laneOffset+0*laneGap, speed:0, step:0, animTime:0, sprite:null,
        stats:{ baseSpeed:3.4, stamina:0.75, sprint:1.10, variance:0.25, fatigue:0.35, kick:0.80, finalBoost:1.2 } },
      { name:'Lightning', lane:2, color:'#FFD700', x:50, y:laneOffset+1*laneGap, speed:0, step:0, animTime:0, sprite:null,
        stats:{ baseSpeed:3.2, stamina:0.95, sprint:1.05, variance:0.18, fatigue:0.25, kick:0.55, finalBoost:1.5 } },
      { name:'Storm',     lane:3, color:'#4169E1', x:50, y:laneOffset+2*laneGap, speed:0, step:0, animTime:0, sprite:null,
        stats:{ baseSpeed:3.0, stamina:1.10, sprint:0.98, variance:0.15, fatigue:0.18, kick:0.45, finalBoost:1.0  } },
      { name:'Blaze',     lane:4, color:'#FF4500', x:50, y:laneOffset+3*laneGap, speed:0, step:0, animTime:0, sprite:null,
        stats:{ baseSpeed:3.6, stamina:0.70, sprint:1.15, variance:0.30, fatigue:0.40, kick:0.60, finalBoost:2  } },
      { name:'Shadow',    lane:5, color:'#2F4F4F', x:50, y:laneOffset+4*laneGap, speed:0, step:0, animTime:0, sprite:null,
        stats:{ baseSpeed:3.1, stamina:1.00, sprint:1.00, variance:0.20, fatigue:0.25, kick:0.90, finalBoost:0.5  } },
    ];

    // Build per-horse config panel
    const horseConfigEl = document.getElementById('horseConfig');
    function makeHorseRow(h) {
      const wrap = document.createElement('div');
      wrap.className = 'horse-info';

      wrap.innerHTML = `
        <div class="row">
          <label>Lane ${h.lane}</label>
          <input type="text" class="nm" value="${h.name}">
          <input type="text" class="hex" value="${h.color}" title="Color (badge)">
        </div>
        <div class="row">
          <label>Sprite</label>
          <input type="file" class="file" accept="image/png,image/webp,image/jpeg">
        </div>
      `;

      // Stats UI
      const statsHtml = document.createElement('div');
      statsHtml.innerHTML = `
        <div class="row"><label>Base</label>
          <input type="number" step="0.1" class="base" value="${h.stats.baseSpeed}">
          <label>Stam</label>
          <input type="number" step="0.05" class="stam" value="${h.stats.stamina}">
        </div>
        <div class="row"><label>Sprint</label>
          <input type="number" step="0.05" class="sprint" value="${h.stats.sprint}">
          <label>Var</label>
          <input type="number" step="0.05" class="var" value="${h.stats.variance}">
        </div>
        <div class="row"><label>Fatigue</label>
          <input type="number" step="0.05" class="fat" value="${h.stats.fatigue}">
        </div>
	<div class="row"><label>Kick</label>
  	<input type="number" step="0.05" min="0" max="1" class="kick" value="${h.stats.kick}">
	</div>
	<div class="row"><label>Final</label>
  	<input type="number" step="0.05" min="1" max="2" class="fboost" value="${h.stats.finalBoost}">
	</div>
      `;
      wrap.appendChild(statsHtml);

      wrap.querySelector('.nm').onchange = e => { h.name = e.target.value.trim() || h.name; refreshLeaderboard(); };
      wrap.querySelector('.hex').onchange = e => { h.color = e.target.value.trim() || h.color; refreshLeaderboard(); };

      statsHtml.querySelector('.base').oninput   = e => h.stats.baseSpeed = +e.target.value || h.stats.baseSpeed;
      statsHtml.querySelector('.stam').oninput   = e => h.stats.stamina   = +e.target.value || h.stats.stamina;
      statsHtml.querySelector('.sprint').oninput = e => h.stats.sprint    = +e.target.value || h.stats.sprint;
      statsHtml.querySelector('.var').oninput    = e => h.stats.variance  = +e.target.value || h.stats.variance;
      statsHtml.querySelector('.fat').oninput    = e => h.stats.fatigue   = +e.target.value || h.stats.fatigue;
      statsHtml.querySelector('.kick').oninput = e => h.stats.kick = +e.target.value || h.stats.kick;
      statsHtml.querySelector('.fboost').oninput = e => h.stats.finalBoost = +e.target.value || h.stats.finalBoost;

      wrap.querySelector('.file').onchange = e => {
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        const img = new Image();
        img.onload = () => { h.sprite = { img, url }; refreshButtonsIfLoaded(); };
        img.src = url;
      };

      return wrap;
    }
    horses.forEach(h => horseConfigEl.appendChild(makeHorseRow(h)));

    // Frames/Scale UI
    const framesInput = document.getElementById('framesInput');
    const scaleInput  = document.getElementById('scaleInput');
    framesInput.value = SPRITE_FRAMES_DEFAULT;
    scaleInput.value  = SPRITE_SCALE_DEFAULT;
    framesInput.oninput = () => { spriteConfig.frames = Math.max(2, Math.min(32, +framesInput.value||SPRITE_FRAMES_DEFAULT)); };
    scaleInput.oninput  = () => { spriteConfig.scale  = Math.max(0.2, Math.min(4, +scaleInput.value||SPRITE_SCALE_DEFAULT)); };

    // Track drawing
    function drawTrack() {
      ctx.fillStyle = '#558B2F';
      ctx.fillRect(0,0,worldWidth,canvas.height);

      ctx.strokeStyle = 'white';
      ctx.lineWidth = 2;
      ctx.setLineDash([10,5]);
      for (let i=0; i<=5; i++) {
        ctx.beginPath();
        ctx.moveTo(0, laneOffset - laneGap/2 + i*laneGap);
        ctx.lineTo(worldWidth, laneOffset - laneGap/2 + i*laneGap);
        ctx.stroke();
      }
      ctx.setLineDash([]);

	// Furlong markers across the track
	const FURLONGS_TOTAL = 8; // adjust if you want more markers
	for (let f = 1; f <= FURLONGS_TOTAL; f++) {
  	// evenly spaced positions from start (x=50) to finishLine (14500)
  	const x = 50 + (finishLine - 50) * (f / FURLONGS_TOTAL);

  	ctx.save();
  	ctx.strokeStyle = 'rgba(255,255,255,0.5)';
  	ctx.lineWidth = 2;
  	ctx.setLineDash([6, 8]);
  	ctx.beginPath();
  	ctx.moveTo(x, laneOffset - laneGap / 2);
  	ctx.lineTo(x, laneOffset - laneGap / 2 + 5 * laneGap);
  	ctx.stroke();
  	ctx.setLineDash([]);

  	// small white post at the top rail
  	ctx.fillStyle = '#fff';
  	ctx.fillRect(x - 2, laneOffset - laneGap / 2 - 14, 4, 10);

  	// label above
  	ctx.font = 'bold 20px Arial';
  	ctx.textAlign = 'center';
  	ctx.textBaseline = 'top';
  	ctx.fillStyle = 'blue';
	ctx.fillText(`${FURLONGS_TOTAL - f + 1}f`, x, 5);
  	ctx.restore();
	}

      // finish line
      ctx.fillStyle = '#FF0000';
      ctx.fillRect(finishLine, 0, 5, canvas.height);
      for (let i=0; i<canvas.height; i+=20) {
        ctx.fillStyle = (i/20)%2===0 ? 'white' : 'black';
        ctx.fillRect(finishLine+5, i, 15, 10);
        ctx.fillRect(finishLine+20, i+10, 15, 10);
      }
    }

    // Sprite drawing
    function drawHorseSprite(horse, dt) {
      const { frames, scale, fps } = spriteConfig;
      const hasSprite = horse.sprite && horse.sprite.img && horse.sprite.img.complete;
	
function drawName(yOffset){
  ctx.font = 'bold 14px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'bottom';
  ctx.strokeStyle = 'rgba(0,0,0,0.6)';
  ctx.lineWidth = 4;
  ctx.strokeText(horse.name, 0, yOffset);
  ctx.fillStyle = '#fff';
  ctx.fillText(horse.name, 0, yOffset);
}




      if (!hasSprite && horseSprite.complete) {
        ctx.save();
        ctx.translate(horse.x, horse.y);

        const animFps = fps + horse.speed * 0.6;
        horse.animTime = (horse.animTime || 0) + animFps * dt;

        const frameWidth  = horseSprite.width / SPRITE_FRAMES_DEFAULT;
        const frameHeight = horseSprite.height;
        const frame       = Math.floor(horse.animTime) % SPRITE_FRAMES_DEFAULT;

        const drawWidth  = frameWidth  * SPRITE_SCALE_DEFAULT;
        const drawHeight = frameHeight * SPRITE_SCALE_DEFAULT;

        ctx.drawImage(
          horseSprite,
          frame * frameWidth, 0, frameWidth, frameHeight,
          -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight
        );
	drawName(-drawHeight * 0.6); // name above the sprite


        ctx.restore();
        return;
      }

      if (!hasSprite) {
        ctx.save();
        ctx.translate(horse.x, horse.y);
        ctx.fillStyle = horse.color;
        ctx.beginPath(); ctx.arc(0,0,18,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font='bold 14px Arial'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillText(horse.lane, 0, 0);
	drawName(-30);
        ctx.restore();
        return;
      }

      const img = horse.sprite.img;
      const frameW = Math.floor(img.width / frames);
      const frameH = img.height;

      const animFps = fps + horse.speed * 0.6;
      horse.animTime = (horse.animTime || 0) + animFps * dt;
      const frameIndex = Math.floor(horse.animTime) % frames;

      const drawW = frameW * scale;
      const drawH = frameH * scale;

      ctx.save();
      ctx.translate(horse.x, horse.y);
      ctx.drawImage(
        img,
        frameIndex * frameW, 0, frameW, frameH,
        -drawW*0.5, -drawH*0.5, drawW, drawH
      );

     drawName(-drawH * 0.6);
      ctx.restore();
    }

    // Leaderboard
    const leaderboard = document.getElementById('leaderboard');
    function refreshLeaderboard() {
      const sorted = [...horses].sort((a,b) => b.x - a.x);
      leaderboard.innerHTML = sorted.map((h,i) => {
        const pct = Math.max(0, Math.round((h.x / finishLine) * 100));
        return `<div class="horse-info">${i+1}. <b>${h.name}</b> ‚Äî Lane ${h.lane} ‚Äî <span style="color:${h.color}">‚óè</span> ${pct}%</div>`;
      }).join('');
    }

    // Physics
    function updateHorses(dt) {
      if (!raceActive || raceFinished) return;

      horses.forEach(h => {
        const prog = Math.min(1, (h.x - 50) / (finishLine - 50));
        const startBoost  = 1 + (h.stats.sprint - 1) * Math.exp(-prog * 6);
        const staminaHold = Math.pow(h.stats.stamina, prog * 2.2);
        const tired       = 1 - h.stats.fatigue * Math.max(0, prog - 0.5);
        const jitter      = (Math.random() - 0.5) * h.stats.variance;
	// original speed calc
	let s = h.stats.baseSpeed * startBoost * staminaHold * tired + jitter;

	// Kick power bursts (short surges; more likely late in the race)
	if (h._kickCooldown == null) h._kickCooldown = 0;
	if (h._kickTimer    == null) h._kickTimer    = 0;

	h._kickCooldown -= dt;
	h._kickTimer    = Math.max(0, h._kickTimer - dt);

	// random small chance to trigger a burst, scaled by kick
	if (h._kickCooldown <= 0 && Math.random() < 0.015 * h.stats.kick) {
  	h._kickTimer    = 0.6 + 0.8 * h.stats.kick;       // burst duration
  	h._kickCooldown = 2.0 + Math.random() * 2.0;      // wait before another burst
	}

	// guaranteed ‚Äúlate kick‚Äù once in the last ~18% if not already bursting
	if (prog > 0.82 && h._kickTimer === 0) {
  	h._kickTimer = 0.7 + 0.9 * h.stats.kick;
	}

	// convert active kick time to a speed multiplier
	const kickBoost = h._kickTimer > 0
  	? 1 + (0.20 + 0.80 * h.stats.kick) * (1 - prog * 0.3) // slightly stronger earlier in the kick
  	: 1;

	// apply kick
	s *= kickBoost;

	// finalBoost ‚Äî one-time burst in last 10% of the race
	if (!h._finalBoostUsed && prog > 0.9) {
 		 s *= h.stats.finalBoost;          // apply burst multiplier
 		 h._finalBoostUsed = true;         // ensure it triggers only once
		}

	// tiny tapering effect if already boosted
	if (h._finalBoostUsed && prog > 0.9) {
 		 s *= 1.0 - (prog - 0.9) * 0.3;    // fade a bit as it crosses the line
		}
	



        h.speed = Math.max(0.8, s);
        h.x += h.speed;
        h.step += h.speed * 0.08;

        if (h.x >= finishLine && !raceFinished) {
          raceFinished = true; raceActive = false; showWinner(h);
        }
      });

      refreshLeaderboard();
    }

    // Race control
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const loadStatus = document.getElementById('loadStatus');

    function startRace() {
      if (raceActive) return;
      raceActive = true; raceFinished = false;
      startBtn.disabled = true;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      lastTs = performance.now();
    }

    function resetRace() {
      raceActive = false; raceFinished = false;
      cameraX = 0;
      horses.forEach(h=>{
        h.x=50; h.speed=0; h.step=0; h.animTime=0;
        h.y = laneOffset + (h.lane-1)*laneGap;
	h._kickTimer = 0;
	h._kickCooldown = 0;
	h._finalBoostUsed = false;
      });
      startBtn.disabled = false;
      resetBtn.disabled = true;
      document.getElementById('winner').style.display = 'none';
      refreshLeaderboard();
    }

    function shuffleLanes() {
      const ids = [1,2,3,4,5].sort(()=>Math.random()-0.5);
      horses.forEach((h,i)=>{ h.lane = ids[i]; h.y = laneOffset + (h.lane-1)*laneGap; });
      refreshLeaderboard();
    }

    function showWinner(horse) {
      const el = document.getElementById('winner');
      el.innerHTML = `üèÜ ${horse.name} WINS! üèÜ<br/><br/>Lane ${horse.lane}`;
      el.style.display = 'block';
      resetBtn.disabled = false;
      startBtn.disabled = true;
    }

    function refreshButtonsIfLoaded() {
      const allReady = horseSprite.complete || horses.some(h => h.sprite?.img?.complete);
      startBtn.disabled   = !allReady;
      resetBtn.disabled   = true;
      shuffleBtn.disabled = !allReady;
      loadStatus.textContent = allReady ? "Sprites loaded. Ready to race!" : "Loading sprites‚Ä¶";
    }
    horseSprite.onload = refreshButtonsIfLoaded;

    // Game loop with camera tracking
    let lastTs = performance.now();
    function loop(ts) {
      const dt = Math.min(0.05, (ts - lastTs) / 1000);
      lastTs = ts;

      // Camera follows leading horse
      if (raceActive || raceFinished) {
        const leader = Math.max(...horses.map(h => h.x));
        const targetCameraX = Math.max(0, Math.min(worldWidth - canvas.width, leader - canvas.width * 0.3));
        cameraX += (targetCameraX - cameraX) * 0.1;
      }

      ctx.save();
      ctx.translate(-cameraX, 0);

      drawTrack();
      horses.slice().sort((a,b)=>a.y-b.y).forEach(h => drawHorseSprite(h, dt));

      ctx.restore();

      updateHorses(dt);

      requestAnimationFrame(loop);
    }

    // Buttons
    startBtn.onclick = startRace;
    resetBtn.onclick = resetRace;
    shuffleBtn.onclick = shuffleLanes;

    // Toggle UI visibility
    const toggleUIBtn = document.getElementById('toggleUI');
    const uiPanel = document.getElementById('ui');
    toggleUIBtn.onclick = () => {
      uiPanel.classList.toggle('hidden');
      toggleUIBtn.textContent = uiPanel.classList.contains('hidden') ? 'Show Settings ‚öôÔ∏è' : 'Hide Settings ‚öôÔ∏è';
    };

    // Init
    refreshLeaderboard();
    refreshButtonsIfLoaded();
    requestAnimationFrame(loop);
  </script>
</body>
</html>